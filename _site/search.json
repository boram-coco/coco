[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Boram-coco",
    "section": "",
    "text": "Everyday with Coco"
  },
  {
    "objectID": "posts/python/python 7_0418.html",
    "href": "posts/python/python 7_0418.html",
    "title": "파이썬 7주차 (0418)",
    "section": "",
    "text": "import numpy as np"
  },
  {
    "objectID": "posts/python/python 7_0418.html#numpy공부-7단계",
    "href": "posts/python/python 7_0418.html#numpy공부-7단계",
    "title": "파이썬 7주차 (0418)",
    "section": "numpy공부 7단계",
    "text": "numpy공부 7단계\n\nnote 1: 메소드 도움말 확인하기\n- 파이썬에서 함수를 적용하는 2가지 방식 - np.sum(a) - a.sum()\n\na=np.array([1,2,3,4,5])\na\n\narray([1, 2, 3, 4, 5])\n\n\n\na.sum()\n\n15\n\n\n\nnp.sum(a)\n\n15\n\n\n- 넘파이에서 a.sum에 대한 도움말은 보통 np.sum()에 자세히 나와있음 \\(\\to\\) np.sum()의 도움말을 확인하고 np.sum(a)와 a.sum()이 동일함을 이용하여 a.sum()의 사용법을 미루어 유추해야함\n\na.sum?\n\n\nnp.sum?\n\n\nnp.sum([0.5, 1.5])\n\n2.0\n\n\n\n\nnote2: hstack, vstack\n- hstack, vstack를 쓰는 사람도 있다.\n\na=np.arange(6)\nb=-a\n\n\nnp.vstack([a,b])\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 0, -1, -2, -3, -4, -5]])\n\n\n\nnp.stack([a,b],axis=0)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 0, -1, -2, -3, -4, -5]])\n\n\n\nnp.hstack([a,b])\n\narray([ 0,  1,  2,  3,  4,  5,  0, -1, -2, -3, -4, -5])\n\n\n\nnp.concatenate([a,b],axis=0)\n\narray([ 0,  1,  2,  3,  4,  5,  0, -1, -2, -3, -4, -5])\n\n\n\nnote3: append\n- 기능1:reshape(-1) + concat\n\na=np.arange(30).reshape(5,6)\nb= -np.arange(8).reshape(2,2,2)\n\n\na.shape, b.shape\n\n((5, 6), (2, 2, 2))\n\n\n\nnp.append(a,b)\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0, -1, -2, -3,\n       -4, -5, -6, -7])\n\n\n\nnp.concatenate([a.reshape(-1), b.reshape(-1)])\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,  0, -1, -2, -3,\n       -4, -5, -6, -7])\n\n\n- 기능2: concat\n\na=np.arange(2*3*4).reshape(2,3,4)\nb=-a\n\n\na.shape, b.shape, np.append(a,b, axis=0).shape   # 대괄호를 쓰지 않아도 됨\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\na.shape, b.shape, np.append(a,b, axis=1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\na.shape, b.shape, np.append(a,b, axis=2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n- concat과의 차이?\n\na=np.arange(2*3*4).reshape(2,3,4)\nb=-a\nc=2*a\n\n\nnp.concatenate([a,b,c],axis=0)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]],\n\n       [[  0,   2,   4,   6],\n        [  8,  10,  12,  14],\n        [ 16,  18,  20,  22]],\n\n       [[ 24,  26,  28,  30],\n        [ 32,  34,  36,  38],\n        [ 40,  42,  44,  46]]])\n\n\n\n\nnote4: revel, flatten\n\na=np.arange(2*3*4).reshape(2,3,4)\na\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n\n\na.reshape(-1) #디멘전 1차원으로\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.ravel()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.flatten()\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\n\nnote 5: 기타 통계함수들\n- 평균, 중앙값, 표준편차, 분산\n\na=np.random.normal(loc=0, scale=2, size=(100,))\na\n\narray([-2.01759369e+00,  1.70831942e+00, -7.66284153e-01,  2.15177363e+00,\n        1.93917905e+00, -2.74073590e-01, -2.04642372e+00, -1.98463689e+00,\n        1.83815582e+00,  4.49207271e+00, -5.40520993e-03,  1.45933943e+00,\n       -1.88730370e+00,  2.53422937e+00, -1.43846951e+00, -2.69938884e-01,\n       -2.68912083e+00,  6.01230062e-01,  1.21155692e+00, -1.78259314e+00,\n        3.08941967e-01,  1.22338707e+00, -1.03232597e+00, -1.79667669e+00,\n        2.19458228e+00,  5.75514508e-01, -3.02570319e+00, -1.21868604e+00,\n       -9.60932070e-01,  1.11771254e+00, -5.34063250e-01, -2.68962004e+00,\n       -4.62864312e+00,  4.64113175e+00, -1.05051461e+00, -6.14152261e-01,\n       -1.56320062e+00,  1.18863285e-01,  1.71819177e+00,  5.04434396e-01,\n       -1.59021839e+00, -8.40274272e-01, -1.92903415e+00, -3.31025301e+00,\n       -5.44121948e+00,  1.71770231e+00,  1.78729433e+00,  1.04315736e+00,\n       -1.44847729e+00,  3.41070754e+00,  2.81655462e+00,  2.88886247e-01,\n        2.61248115e+00, -5.28811327e-01, -2.47391400e+00, -6.04240520e-02,\n       -2.86388739e+00,  2.50495252e+00,  5.34019240e+00,  8.27782165e-01,\n       -2.19088172e+00, -7.82626427e-01, -1.12548033e+00, -2.09109091e+00,\n       -2.06466297e+00, -5.36374068e-01, -3.65861892e+00, -1.42345921e+00,\n       -6.67080354e-01, -2.57114581e+00, -2.37356246e-01, -1.01485014e-02,\n       -3.65219208e+00,  1.30174327e+00,  9.43287089e-01, -5.41965726e-01,\n        1.89596089e+00, -3.26373304e+00, -1.66761926e+00, -1.14963754e+00,\n        4.34701574e-01, -4.87043020e-01, -5.10792557e-01, -9.05609502e-01,\n        3.51588424e-01, -9.72910253e-01, -1.11823422e+00, -8.02920775e-01,\n       -1.51091269e+00,  4.97543437e-01, -8.98957916e-03,  1.47902427e+00,\n       -8.44007525e-01, -5.03900902e-01,  1.26720080e+00, -5.25199252e+00,\n       -3.15857694e+00,  2.43006841e+00, -6.43759610e-01,  1.16296529e+00])\n\n\n\nnp.mean(a)\n\n-0.34664187661644286\n\n\n\nnp.median(a)\n\n-0.5352186588272133\n\n\n\nnp.std(a)\n\n2.0168674618593685\n\n\n\nnp.var(a)\n\n4.0677543587070515\n\n\n- corr matrix, cov matrix\n\nnp.random.seed(43052)\nx=np.random.randn(10000)\ny=np.random.randn(10000)*2\nz=np.random.randn(10000)*0.5\n\n\nnp.corrcoef([x,y,z]).round(2)\n\narray([[ 1.  , -0.01,  0.01],\n       [-0.01,  1.  ,  0.  ],\n       [ 0.01,  0.  ,  1.  ]])\n\n\n\nnp.cov([x,y,z]).round(2)\n\narray([[ 0.99, -0.02,  0.  ],\n       [-0.02,  4.06,  0.  ],\n       [ 0.  ,  0.  ,  0.25]])\n\n\n\n\nnote 6 : dtype\n- np.array는 항상 dtype이 있다.\n\na=np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\na.dtype\n\ndtype('int32')\n\n\n\na=np.array([1.0,2.0,3.0])\na\n\narray([1., 2., 3.])\n\n\n\na.dtype\n\ndtype('float64')\n\n\n\na=1\ntype(a)\n\nint\n\n\n\na=1.0\ntype(a)\n\nfloat\n\n\n- 같은 int라도 int16, int32, int64으로 나누어진다.\n\na= np.array([1,2,3], dtype=np.int64)\na\n\narray([1, 2, 3], dtype=int64)\n\n\n\na= np.array([1,2,3], dtype=np.int32)\na\n\narray([1, 2, 3])\n\n\n\na.dtype\n\ndtype('int32')\n\n\n- float도 float16, float32, float64가 있다.\n\na=np.array([1,2,3],dtype=np.float64) #64는 기본이라 표시가 안된당. \na\n\narray([1., 2., 3.])\n\n\n\na=np.array([1,2,3],dtype=np.float32)\na\n\narray([1., 2., 3.], dtype=float32)\n\n\n- 데이터타입은 아래와 같은 방법으로 변환시킬 수 있다.\n\na = np.array([1,2,3],dtype=np.int32)\na\n\narray([1, 2, 3])\n\n\n\na=a.astype(dtype=np.int64)\n\n\na.dtype\n\ndtype('int64')\n\n\n- 문자열의 경우\n\na= np.array(['a','b','c'])\na\n\narray(['a', 'b', 'c'], dtype='<U1')\n\n\n\na= np.array(['ab','b','c'])\na\n\narray(['ab', 'b', 'c'], dtype='<U2')\n\n\n\na= np.array(['absfd','b','c'])\na\n\narray(['absfd', 'b', 'c'], dtype='<U5')\n\n\n- 문자열+숫자혼합 => 문자열로 통일\n\na=np.array(['a',1])\na\n\narray(['a', '1'], dtype='<U11')\n\n\n\na=np.array(['a',1423])\na\n\narray(['a', '1423'], dtype='<U11')\n\n\n\na=np.array(['a',1.0])\na\n\narray(['a', '1.0'], dtype='<U32')\n\n\n- 숫자를 문자열로 전환:\n\na=np.array([1,2,3])\na\n\narray([1, 2, 3])\n\n\n\na.astype(np.str_)\n\n# 문자열 타입으로 바뀌는\n\narray(['1', '2', '3'], dtype='<U11')\n\n\n\n\nnote 7: 브로드캐스팅과 시간측정\n(예비학습)\n\nimport time\n\n\nt1=time.time()\n\n\nt2=time.time()\nt2-t1\n\n14.808058738708496\n\n\n예비학습끝\n(예제) x=[0,1,2,3,4]인 벡터가 있다고 하자. (i,j)의 원소는 (x[i]-x[j])**2를 의미하는 \\(5\\times5\\) 매트릭스를 구하라..\n(풀이)\n\nx=np.array(range(5))\nx\n\narray([0, 1, 2, 3, 4])\n\n\n\ndist= np.zeros([5,5])\ndist\n\narray([[0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.]])\n\n\n\nfor i in range(5):\n    for j in range(5):\n        dist[i,j] = (x[i]-x[j])**2\n\n\ndist\n\narray([[ 0.,  1.,  4.,  9., 16.],\n       [ 1.,  0.,  1.,  4.,  9.],\n       [ 4.,  1.,  0.,  1.,  4.],\n       [ 9.,  4.,  1.,  0.,  1.],\n       [16.,  9.,  4.,  1.,  0.]])\n\n\n(풀이2)\n\nx1=x.reshape(5,1).astype(dtype=np.float64)\nx2=x.reshape(1,5).astype(dtype=np.float64)\n\n\nx1\n\narray([[0.],\n       [1.],\n       [2.],\n       [3.],\n       [4.]])\n\n\n\nx2\n\narray([[0., 1., 2., 3., 4.]])\n\n\n\nx1-x2\n\narray([[ 0., -1., -2., -3., -4.],\n       [ 1.,  0., -1., -2., -3.],\n       [ 2.,  1.,  0., -1., -2.],\n       [ 3.,  2.,  1.,  0., -1.],\n       [ 4.,  3.,  2.,  1.,  0.]])\n\n\n\n(i,j)th element = x[i] - x[j]\n\n\n(x1-x2)**2\n\narray([[ 0,  1,  4,  9, 16],\n       [ 1,  0,  1,  4,  9],\n       [ 4,  1,  0,  1,  4],\n       [ 9,  4,  1,  0,  1],\n       [16,  9,  4,  1,  0]], dtype=int32)\n\n\n\n\ny=x=np.array(range(10000))\n\n\ndist= np.zeros([10000,10000])\ndist\n\narray([[0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       ...,\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.],\n       [0., 0., 0., ..., 0., 0., 0.]])\n\n\n\nt1=time.time()\nfor i in range(10000):\n    for j in range(10000):\n        dist[i,j] = (y[i]-y[j])**2\nt2=time.time()\nt2-t1\n\n66.71002793312073\n\n\n\ny1=y.reshape(10000,1).astype(np.float64)\ny2=y.reshape(1,10000).astype(np.float64)\n\n\nt1=time.time()\ndist2=(y1-y2)**2\nt2=time.time()\nt2-t1\n\n0.426450252532959\n\n\n\ndist[:5,:5], dist2[:5,:5]\n\n(array([[ 0.,  1.,  4.,  9., 16.],\n        [ 1.,  0.,  1.,  4.,  9.],\n        [ 4.,  1.,  0.,  1.,  4.],\n        [ 9.,  4.,  1.,  0.,  1.],\n        [16.,  9.,  4.,  1.,  0.]]),\n array([[ 0.,  1.,  4.,  9., 16.],\n        [ 1.,  0.,  1.,  4.,  9.],\n        [ 4.,  1.,  0.,  1.,  4.],\n        [ 9.,  4.,  1.,  0.,  1.],\n        [16.,  9.,  4.,  1.,  0.]]))\n\n\n\n(dist-dist2).sum()\n\n0.0"
  },
  {
    "objectID": "posts/python/python 7_0418.html#matplotlib",
    "href": "posts/python/python 7_0418.html#matplotlib",
    "title": "파이썬 7주차 (0418)",
    "section": "matplotlib",
    "text": "matplotlib\n\nimport matplotlib.pyplot as plt\n\n\nplt.plot\n- 기본그림\n\nplt.plot([1,2,3],[3,4,5],'.')\n\n\n\n\n\nplt.plot(np.array([1,2,3]),np.array([3,4,5]),'.')\n\n\n\n\n- 예제들\n\nt=np.linspace(-6,6,100)\nt\n\narray([-6.        , -5.87878788, -5.75757576, -5.63636364, -5.51515152,\n       -5.39393939, -5.27272727, -5.15151515, -5.03030303, -4.90909091,\n       -4.78787879, -4.66666667, -4.54545455, -4.42424242, -4.3030303 ,\n       -4.18181818, -4.06060606, -3.93939394, -3.81818182, -3.6969697 ,\n       -3.57575758, -3.45454545, -3.33333333, -3.21212121, -3.09090909,\n       -2.96969697, -2.84848485, -2.72727273, -2.60606061, -2.48484848,\n       -2.36363636, -2.24242424, -2.12121212, -2.        , -1.87878788,\n       -1.75757576, -1.63636364, -1.51515152, -1.39393939, -1.27272727,\n       -1.15151515, -1.03030303, -0.90909091, -0.78787879, -0.66666667,\n       -0.54545455, -0.42424242, -0.3030303 , -0.18181818, -0.06060606,\n        0.06060606,  0.18181818,  0.3030303 ,  0.42424242,  0.54545455,\n        0.66666667,  0.78787879,  0.90909091,  1.03030303,  1.15151515,\n        1.27272727,  1.39393939,  1.51515152,  1.63636364,  1.75757576,\n        1.87878788,  2.        ,  2.12121212,  2.24242424,  2.36363636,\n        2.48484848,  2.60606061,  2.72727273,  2.84848485,  2.96969697,\n        3.09090909,  3.21212121,  3.33333333,  3.45454545,  3.57575758,\n        3.6969697 ,  3.81818182,  3.93939394,  4.06060606,  4.18181818,\n        4.3030303 ,  4.42424242,  4.54545455,  4.66666667,  4.78787879,\n        4.90909091,  5.03030303,  5.15151515,  5.27272727,  5.39393939,\n        5.51515152,  5.63636364,  5.75757576,  5.87878788,  6.        ])\n\n\n\nx=np.sin(t)\ny=np.cos(t)\n\n\nplt.plot(t,x)\n\n\n\n\n\nplt.plot(t,y)\n\n\n\n\n\nplt.plot(t,x)\nplt.plot(t,y)\n\n\n\n\n\nplt.plot(t,x)\nplt.plot(t,y,'.')\n\n\n\n\n\nplt.plot(t,x)\nplt.plot(t,y,'--')\n\n\n\n\n\n\nplt.hist\n\nX=np.random.randn(1000)\n\n\nplt.hist(X)\n\n(array([  3.,  14.,  66., 157., 232., 245., 155.,  92.,  28.,   8.]),\n array([-3.29472542, -2.65210581, -2.0094862 , -1.36686658, -0.72424697,\n        -0.08162736,  0.56099226,  1.20361187,  1.84623148,  2.4888511 ,\n         3.13147071]),\n <BarContainer object of 10 artists>)\n\n\n\n\n\n\nY=np.random.rand(1000)\nplt.hist(Y)\n\n(array([ 98., 127., 107.,  87.,  83.,  86.,  85., 118., 110.,  99.]),\n array([0.00162071, 0.10140453, 0.20118836, 0.30097218, 0.40075601,\n        0.50053983, 0.60032366, 0.70010748, 0.79989131, 0.89967513,\n        0.99945896]),\n <BarContainer object of 10 artists>)\n\n\n\n\n\n\nplt.hist(X)\nplt.hist(Y)\n\n(array([ 98., 127., 107.,  87.,  83.,  86.,  85., 118., 110.,  99.]),\n array([0.00162071, 0.10140453, 0.20118836, 0.30097218, 0.40075601,\n        0.50053983, 0.60032366, 0.70010748, 0.79989131, 0.89967513,\n        0.99945896]),\n <BarContainer object of 10 artists>)"
  },
  {
    "objectID": "posts/python/python 5_0406.html",
    "href": "posts/python/python 5_0406.html",
    "title": "파이썬 5주차 (0406)",
    "section": "",
    "text": "!pip install numpy \n\nCollecting numpy\n  Downloading numpy-1.24.1-cp39-cp39-win_amd64.whl (14.9 MB)\n     --------------------------------------- 14.9/14.9 MB 10.7 MB/s eta 0:00:00\nInstalling collected packages: numpy\nSuccessfully installed numpy-1.24.1\n\n\n\nimport numpy as np"
  },
  {
    "objectID": "posts/python/python 5_0406.html#넘파이-공부-1단계",
    "href": "posts/python/python 5_0406.html#넘파이-공부-1단계",
    "title": "파이썬 5주차 (0406)",
    "section": "넘파이 공부 1단계",
    "text": "넘파이 공부 1단계\n\n선언\n\nlist([1,2,3])\n\n[1, 2, 3]\n\n\n\n[1,2,3]\n\n[1, 2, 3]\n\n\n\na=np.array([1,2,3])  # list만들고 ndarray화 시킴\nl=[1,2,3]\n\n\n\n기본연산 브로드캐스팅\n\na\n\narray([1, 2, 3])\n\n\n\nl\n\n[1, 2, 3]\n\n\n\na+1 ## [1,2,3] + 1 = [2,3,4]\n\narray([2, 3, 4])\n\n\n\nl+1\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n\na+np.array([-1,-2,-3])\n\narray([0, 0, 0])\n\n\n\na-a\n\narray([0, 0, 0])\n\n\n\nl-l  # 리스트는 안됨\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n\na*2\n\narray([2, 4, 6])\n\n\n\nl*2\n\n[1, 2, 3, 1, 2, 3]\n\n\n\na/2\n\narray([0.5, 1. , 1.5])\n\n\n\nl/2\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n\na**2\n\narray([1, 4, 9])\n\n\n\nl**2\n\nTypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'\n\n\n\na%2   # %2 = 2로 나눈 나머지 리턴\n\narray([1, 0, 1], dtype=int32)\n\n\n\nl%2\n\nTypeError: unsupported operand type(s) for %: 'list' and 'int'\n\n\n\n\n기타 수학연산 지원\n\nnp.sqrt(2)\n\n1.4142135623730951\n\n\n\nnp.sqrt(a), np.sqrt(l)\n\n(array([1.        , 1.41421356, 1.73205081]),\n array([1.        , 1.41421356, 1.73205081]))\n\n\n\nnp.log(a), np.log(l)\n\n(array([0.        , 0.69314718, 1.09861229]),\n array([0.        , 0.69314718, 1.09861229]))\n\n\n\nnp.exp(a), np.exp(l)\n\n(array([ 2.71828183,  7.3890561 , 20.08553692]),\n array([ 2.71828183,  7.3890561 , 20.08553692]))\n\n\n\nnp.sin(a), np.sin(l)\n\n(array([0.84147098, 0.90929743, 0.14112001]),\n array([0.84147098, 0.90929743, 0.14112001]))"
  },
  {
    "objectID": "posts/python/python 5_0406.html#넘파이-공부-2단계",
    "href": "posts/python/python 5_0406.html#넘파이-공부-2단계",
    "title": "파이썬 5주차 (0406)",
    "section": "넘파이 공부 2단계",
    "text": "넘파이 공부 2단계\n\n인덱싱 1차원\n- 선언\n\nl=[11,22,33,44,55,66]\na=np.array(l)\n\n- 인덱스로 접근\n\nl[0], l[1], l[2], l[3], l[4], l[5]\n\n(11, 22, 33, 44, 55, 66)\n\n\n\na[0], a[1], a[2], a[3], a[4], a[5]\n\n(11, 22, 33, 44, 55, 66)\n\n\n- : 이용 (슬라이싱)\n\nl[2:4] # index 2에서 시작, index 4는 포함하지 않음\n\n[33, 44]\n\n\n\na[2:4]\n\narray([33, 44])\n\n\n- 점수배열에 의한 익덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\n  a[[0,2,4]]  # index=0, index=2, index=4 에 해당하는 원소를 뽑고 싶다 -> 가능\n\narray([11, 33, 55])\n\n\n\n l[[0,2,4]]    # 리스트는 불가능\n\nTypeError: list indices must be integers or slices, not list\n\n\n- 부울값에 의한 인덱싱\n\na\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na[[True, True, False, True, False, False]]\n\narray([11, 22, 44])\n\n\n응용하면?\n\na<33\n\narray([ True,  True, False, False, False, False])\n\n\n\na[[ True,  True, False, False, False, False]]\n\narray([11, 22])\n\n\n\na[a<33]\n\narray([11, 22])\n\n\n리스트는 불가능\n\nl<33\n\nTypeError: '<' not supported between instances of 'list' and 'int'\n\n\n\nl[[True, True, False, True, False, False]]\n\nTypeError: list indices must be integers or slices, not list\n\n\n\n\n인덱싱 2차원\n- 중첩리스트와 2차원 np.array 선언\n\nA = [[1,2,3,4],[-1,-2,-3,-4],[5,6,7,8],[-5,-6,-7,-8]]\nA2 = np.array(A)\n\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA\n\n[[1, 2, 3, 4], [-1, -2, -3, -4], [5, 6, 7, 8], [-5, -6, -7, -8]]\n\n\n- A의 원소 인덱싱\n\nA[0][0] # A의 (1,1)의 원소\n\n1\n\n\n\nA[1][2] # A의 (2,3)의 원소\n\n-3\n\n\n\nA[-1][0] # A의 (4,1)의 원소\n\n-5\n\n\n- A2의 원소 인덱싱\n\nA2[0][0]\n\n1\n\n\n\nA2[1][2] # A2의 (2,3)의 원소\n\n-3\n\n\n\nA2[-1][0] # A2의 (4,1)의 원소\n\n-5\n\n\n- A2에서만 되는 기술 (넘파이에서 제시하는 신기술, R에서는 기본적으로 쓰던것, 이중list는 불가능)\n\nA2[0,0]\n\n1\n\n\n\nA2[1,2] # A2의 (2,3)의 원소\n\n-3\n\n\n\nA2[-1,0] # A2의 (4,1)의 원소\n\n-5\n\n\n- 정수배열에 의한 인덱싱 & 슬라이싱!\n\nA2\n\narray([[ 1,  2,  3,  4],\n       [-1, -2, -3, -4],\n       [ 5,  6,  7,  8],\n       [-5, -6, -7, -8]])\n\n\n\nA2[0,0:2]   # 1행 1열, 1행 2열\n\narray([1, 2])\n\n\n\nA2[0,:]  # 1행\n\narray([1, 2, 3, 4])\n\n\n\nA2[0]  # 1행\n\narray([1, 2, 3, 4])\n\n\n\nA2[[0,2],:]   # 1행, 3행\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[[0,2]]   # 1행, 3행\n\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n\n\n\nA2[:,0] # 1열\n\narray([ 1, -1,  5, -5])\n\n\n\nA2[:,[0]] # 1열\n\narray([[ 1],\n       [-1],\n       [ 5],\n       [-5]])\n\n\n\nA2[:,[0,2]] # 1열, 3열\n\narray([[ 1,  3],\n       [-1, -3],\n       [ 5,  7],\n       [-5, -7]])\n\n\n\nA2[0:2,[0,2]]  # 1행-2행 / 1열-3열\n\narray([[ 1,  3],\n       [-1, -3]])\n\n\n\n\n1차원 배열의 선언\n- 리스트나 튜플을 선언하고 형변환\n\nnp.array((1,2,3)) # 튜플->넘파이어레이\n\narray([1, 2, 3])\n\n\n\nnp.array([1,2,3]) # 리스트->넘파이어레이\n\narray([1, 2, 3])\n\n\n- range()를 이용해서 선언하고 형변환\n\nnp.array(range(10))  # range(10)->넘파이어레이\n\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n- np.zeros, np.ones\n\nnp.zeros(3)\n\narray([0., 0., 0.])\n\n\n\nnp.ones(4)\n\narray([1., 1., 1., 1.])\n\n\n- np.linspace\n\nnp.linspace(0,1,12)   # 0부터 1까지 12개로 쪼개기   (양끝점 모두 포함)\n\narray([0.        , 0.09090909, 0.18181818, 0.27272727, 0.36363636,\n       0.45454545, 0.54545455, 0.63636364, 0.72727273, 0.81818182,\n       0.90909091, 1.        ])\n\n\n\nlen(np.linspace(0,1,12))\n\n12\n\n\n- np.arange\n\nnp.arange(5)  #np.array(range(5))\n\narray([0, 1, 2, 3, 4])\n\n\n\nnp.arange(1,6)   #np.array(range(1,6))\n\narray([1, 2, 3, 4, 5])\n\n\n\n\nreshape\n- reshape: ndarray의 특수한 기능\n\na=np.array([11,22,33,44,55,66])\na  #길이가 6인 벡터\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\ntype(a)\n\nnumpy.ndarray\n\n\n\na.reshape\n\n<function ndarray.reshape>\n\n\n\na.reshape(2,3)  # (2,3) matrix라고 생각해도 무방\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\na.reshape(5,2)\n\nValueError: cannot reshape array of size 6 into shape (5,2)\n\n\nnote: reshape은 a자체를 변홧키는 것은 아님\n\na  # reshape은 a자체는 변화하지 않음\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\nb=a.reshape(2,3)  # a를 reshape한 결과를 b에 저장\nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\n a  # a는 여전히 그대로 있음\n\narray([11, 22, 33, 44, 55, 66])\n\n\n- 다시 b를 a처럼 바꾸고 싶다.\n\nb\n\narray([[11, 22, 33],\n       [44, 55, 66]])\n\n\n\nb.reshape(6) # b는 (2,3) matrix, 그런데 이것을 길이가 6인 벡터로 만들고 싶다.\n\narray([11, 22, 33, 44, 55, 66])\n\n\n\na.shape   # 길이가 1인 튜플\n\n(6,)\n\n\n\nb.shape   # 길이가 2인 튜플이니까 2차원 \n\n(2, 3)\n\n\n- reshape with -1\n\na=np.arange(24)  #np.array(range(24))\na\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\na.reshape(2,?) # 에러..\n\nSyntaxError: invalid syntax (2529973538.py, line 1)\n\n\n\na.reshape(2,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(3,-1)\n\narray([[ 0,  1,  2,  3,  4,  5,  6,  7],\n       [ 8,  9, 10, 11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(4,-1)\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\na.reshape(7,-1)  # 나눠떨어지지 않으니까.. \n\nValueError: cannot reshape array of size 24 into shape (7,newaxis)\n\n\n\nb=a.reshape(12,-1)\nb\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 4,  5],\n       [ 6,  7],\n       [ 8,  9],\n       [10, 11],\n       [12, 13],\n       [14, 15],\n       [16, 17],\n       [18, 19],\n       [20, 21],\n       [22, 23]])\n\n\n\nb.reshape(24) # b를 다시 길이가 24인 벡터로 만들고 싶다.\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\nb.reshape(-1) # b를 다시 길이가 24인 벡터로 만들고 싶다.\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19, 20, 21, 22, 23])\n\n\n\n\n2차원 배열의 선언\n\n\nnp.zeros((3,3))\n\narray([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones((3,3))\n\narray([[1., 1., 1.],\n       [1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nnp.eye(3) \n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\n\nnp.diag([1,2,3,-1])\n\narray([[ 1,  0,  0,  0],\n       [ 0,  2,  0,  0],\n       [ 0,  0,  3,  0],\n       [ 0,  0,  0, -1]])\n\n\n\n\n랜덤으로 생성\n\nnp.random.randn(10)  # 표준정규분포에서 10개를 뽑음\n\narray([-1.62694735, -0.46057632,  0.9092888 , -0.52150285, -0.0409467 ,\n        0.98561001,  1.87613924, -2.08870029,  0.28577046, -0.15794105])\n\n\n\nnp.random.rand(10)  # 0~1 사이에서 10개를 뽑음\n\narray([0.7377278 , 0.61091057, 0.17571601, 0.29298532, 0.90149596,\n       0.84002052, 0.50700681, 0.40217981, 0.30557984, 0.34392417])\n\n\n\nnp.random.randn(4).reshape(2,2)  # 표준정규분포에서 4개를 뽑고 (2,2) nparray로 형태변환\n\narray([[0.50093512, 0.74336071],\n       [0.91296027, 0.04033486]])\n\n\n\nnp.random.rand(4).reshape(2,2)  # 0~1에서 4개를 뽑고 (2,2) nparray로 형태변환\n\narray([[0.30484011, 0.57731961],\n       [0.30645542, 0.2189475 ]])\n\n\n\n\n행렬\n\nA=np.array(range(4)).reshape(2,2)\nA\n\narray([[0, 1],\n       [2, 3]])\n\n\n\nA.T #전치행렬\n\narray([[0, 2],\n       [1, 3]])\n\n\n\nnp.linalg.inv(A)   # 역행렬\n\narray([[-1.5,  0.5],\n       [ 1. ,  0. ]])\n\n\n\nA @ np.linalg.inv(A)  # 단위행렬   # @는 행렬곱을 수행\n\narray([[1., 0.],\n       [0., 1.]])"
  },
  {
    "objectID": "posts/python/python 5_0406.html#숙제",
    "href": "posts/python/python 5_0406.html#숙제",
    "title": "파이썬 5주차 (0406)",
    "section": "숙제",
    "text": "숙제\n\nA=np.array(range(6))\nA # 길이가 6인 벡터\n\narray([0, 1, 2, 3, 4, 5])\n\n\n위와 같이 길이가 6인 벡터 A를 (2,3) ndarray로 변경\n\nA.reshape(2,3)\n\narray([[0, 1, 2],\n       [3, 4, 5]])\n\n\n\nlen(A.reshape(2,3))\n\n2"
  },
  {
    "objectID": "posts/python/python 3_0321.html",
    "href": "posts/python/python 3_0321.html",
    "title": "파이썬 3주차 (0321)",
    "section": "",
    "text": "(리스트가 아니고) 튜플을 쓰는 이유\n- 책의 설명 (파이썬에 한정되는 것은 아니고 모든 언어에 존재하는 불변형 객체에 적용가능한 설명) - 실수방지 - 빠르다, 다중작업에 유리하다, 여러사람과 작업하기에 유리하다, 깊은복사/얕은복사시 원하지 않는 오류(side effect라고 함)를 방지할 수 있다, 메모리관리에도 유리함 등등 - 느낌: 불변형은 기능제한이 있는데 가볍고 빠른, 가변형은 기능은 풍부하지만 약간 느리고 무거운 느낌임 (불변형: 라면사리, 가변형:라면)\n- 교수님 설명 (파이썬 한정 불변객체, 즉 튜플에 대한 설명) - 튜플의 장점은 소괄호의 생략에 있음 (파이썬과 줄리아만 가능) - 이것이 언패킹구문과 결합하여 어마무시한 가독성을 제공한다.\n\ndef mycal(a,b):\n    return a+b, a-b, a*b, a/b # 여러개의 값을 리턴하는 듯 보인다. ->  사실은 길이가 4인 튜플 1개를 리턴\n\n\nmycal(2,3)\n\n(5, -1, 6, 0.6666666666666666)\n\n\n\n_, _, mulrslt, _ = mycal(2,3) # 병렬할당\n\n\nmulrslt\n\n6\n\n\n- 의문: 왜 튜플만 괄호를 생략할 수 있지?\n- 교수님 생각 - 튜플을 먼저 만들고, 괄호를 생략하는 문법을 추가한것은 아닐것임 - 원래 괄호없이 컴마만 대충찍어서 선언가능한 간단한 타입의 벡터형을 만들고 싶었을 것임 - 왜? 괄호없는 벡터를 만들고 + 연패킹을 사용하면 여러가지 구문들이 엄청나게 간단해짐 - 컴마컴마로 선언하는 벡터는 한 두번 쓰고 버리는 경우가 많으며 대부분 이름도 필요 없음 -> 원소에 접근해서 sorting하여 순서를 바꾸고 싶다던가 원소를 추가할 이유가 없음 -> 비싼 가변형으로 만들 이유가 없다. - 필요한것: 데이터가 벡터의 형태로 모여있기만 하면 된다.\n- 다른사람들 의견 (컴공과) - 튜플 + 언패킹에 충격 \\(\\to\\) 파이썬 편하다..\n\n\n인덱싱고급(스트라이딩)\n- 스트라이딩 [start:stop:step]\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[0:8:2]\n\n['a', 'c', 'e', 'g']\n\n\n- 생략\n\nlst[:]\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::2]\n\n['a', 'c', 'e', 'g']\n\n\n\nlst[:8:2]\n\n['a', 'c', 'e', 'g']\n\n\n- 예제: 짝수/홀수 원소 추출\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::2]  # 1,3,5,7, ... 홀수 원소\n\n['a', 'c', 'e', 'g']\n\n\n\nlst[1::2] # 2,4,6,8,... 짝수 원소\n\n['b', 'd', 'f', 'h']\n\n\n- step = -1이면?\n\nlst[::-1]    # 뒤에서부터\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\nreverse와 같은 기능\n\n(reverse)와 비교\n관찰1: reverse 메소드는 리소드 자체를 변화시킴\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst.reverse()  # 리버스는 자체가 변화한다.\nlst  \n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n관찰2: [::-1] 는 리스트는 변화시키지 않음\n\nlst = list('abcdefgh')\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\nlst\n\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n\n\n- 사실 -step은 쓰는 것이 조금 까다롭다.\n(예제) 처음과 끝을 생략하지 않고 아래와 동일한 효과를 주는 코드를 만들어 보자.\n\nlst = list('abcdefgh')\nlst[::-1]\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n결국 lst[?:?:-1]의 꼴에서 적당히 ?의 값을 채우면 된다.\n\nlst[-1::-1] # 일단 첫 시작ㄷ은 제일 마지막 원소\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n\nlst[-1:0:-1] # 마지막 인덱스는 포함x\n\n['h', 'g', 'f', 'e', 'd', 'c', 'b']\n\n\n\nlst[-1:-1:-1] \n\n[]\n\n\n잠깐 인덱스를 생각해보자.\n\n\n\na\nb\nc\nd\ne\nf\ng\nh\n\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n\n\n\n\nlst[-1:-8:-1] \n\n['h', 'g', 'f', 'e', 'd', 'c', 'b']\n\n\n\nlst[-1:-9:-1] \n\n['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n\n(예제)\n\nlst[2::2]\n\n['c', 'e', 'g']\n\n\n\nlst[-2::-2]\n\n['g', 'e', 'c', 'a']\n\n\n\nlst[-2:2:2]\n\n[]\n\n\n\nlst[2:3:2]\n\n['c']\n\n\n\nlst[2:2:2]\n\n[]\n\n\n\nlst[2:2:-2]\n\n[]\n\n\n결론: -step을 자주 쓰진 말자\n\n\n컴프리헨션 고급 (if문이 포함된 컴프리헨션)\n- 예제: 제곱수준에서 12로 나누어 떨어지는 수만 원소로 가지는 리스트를 만들고 싶다. - 제곱수: 1,4, 9, 16, 25, 36, … - 12로 나누어 떨어지는 수: 36…\n(예비학습)\n\n12 % 5 # 나머지 리턴\n\n2\n\n\n(풀이)\n\nlst=[]\nfor i in range(1,101):\n    if (i**2 % 12 == 0 ):\n        lst.append(i**2)\n\n\nlst\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]\n\n\n(풀이2)\n\n[i**2 for i in range(1,101) if (i**2 % 12==0)]\n\n[36,\n 144,\n 324,\n 576,\n 900,\n 1296,\n 1764,\n 2304,\n 2916,\n 3600,\n 4356,\n 5184,\n 6084,\n 7056,\n 8100,\n 9216]\n\n\n\n\n함수고급 (조건부리턴)\n- 홀수 짝수를 판별하는 함수 만들기1\n\ndef test(a):\n    if a% 2 ==0:\n        return 'even'\n    else:\n        return 'odd'\n\n\ntest(0)\n\n'even'\n\n\n\ntest(3)\n\n'odd'\n\n\n\n[test(a) for a in range(1,11)]\n\n['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']\n\n\n- 홀수 짝수를 판별하는 함수 만들기2\n\ndef test(a):\n    return 'even' if a%2==0 else 'odd'\n\n\ntest(2)\n\n'even'\n\n\n\n[test(a) for a in range(1,11)]\n\n['odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even', 'odd', 'even']\n\n\n\n\nlen함수\n- 0차원 자료형은 len함수가 동작하지 않음\n\na=1\nlen(a)\n\nTypeError: object of type 'int' has no len()\n\n\n\na=True\nlen(a)\n\nTypeError: object of type 'bool' has no len()\n\n\n\na=3.14\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nnote: 이것이 어떠한 수학적인 의미를 가지거나 0차원의 본질적인 진리를 뜻하는 것은 아니다. R에서는 1, 3.14, True의 길이가 1로 존재함\n\n- 1차원 자료형은 len함수가 동작\n\na='boram'\nlen(a)\n\n5\n\n\n\na=[1,2,3,4,5,6,7]\nlen(a)\n\n7\n\n\n\na=1,2,3,4\nlen(a)\n\n4\n\n\n\na=range(10)\nlen(a)\n\n10\n\n\n- 길이가 1인 1차원 자료형과 0차원 자료형은 다른것임\n\na='g'\nlen(a)\n\n1\n\n\n\na=[1]   \nlen(a)\n\n1\n\n\n\na=(1,)\nlen(a)\n\n1\n\n\n\na=range(1)\nlen(a)\n\n1\n\n\n- 길이가 0인 1차원 자료형도 존재함\n\na=''\nlen(a)\n\n0\n\n\n\na=[]\nlen(a)\n\n0\n\n\n\na=()\nlen(a)\n\n0\n\n\n\na=range(0)\nlen(a)\n\n0\n\n\n\n\nsummary : str, list, tuple\n- str,list, tuple은 모두 시퀀스형이라는 공통점이 있다. \\(\\to\\) 원소의 위치번호로 인덱싱이 가능\n\nlst=[1,2,3,4]\n\n\nlst[0]  #위치번호=0\n\n1\n\n\n\nlst[-1]  #위치번호=1\n\n4\n\n\n- str, list, tuple은 차이점도 존재함. 잠깐 정리해보자.\n*** 시퀀스형의 카테고리***\n\n컨테이너형: list, tuple\n균일형: str\n가변형: list\n불변형: tuple, str\n\n*****표로 정리하면*****\n\n\n\n\n컨테이너형\n균일형\n\n\n\n\n가변형\nlist\n-\n\n\n불변형\ntuple\nstr\n\n\n\n- 시퀀스형이 아닌 1차원 자료형도 있을까? 원소의 위치번호로 인덱싱이 불가능한 자료형\n- 왜 이런게 필요할까? - 벡터에서 원소를 뽑는것은 정보의 모임에서 정보를 검색하는 것과 같다. - 정보를 순서대로 나열한 뒤에 그 순서를 이용하여 검색하는 방법은 유용하다. - 하지만 경우에 따라서는 키워드 를 기억해서 그 키워드를 바탕으로 정보에 접근하는 방법이 유용할 수 있다.\n****카카오톡 대화내용 검색****\n(상황1) 오늘 아침에 와이프가 뭔가를 카톡으로 부탁함. 그런데 그 뭔가가 기억안남.\n(상황2) 개강전에 동료교수와 함께 저녁약속을 카톡으로 잡았었음. 그런데 그게 언제인지 기억안남.\n(상황3) 오늘아침 동료교수와 함께 점심약속을 카톡으로 잡았었음. 그런데 그 장소가 기억나지 않음\n- 순서대로 정리된 자료를 검색할때는 시퀀스형이 유리하다. 그런데 키워드로 검색하고 싶을 경우는 딕셔너리 타입이 유리하다.\n\n\ndict\n선언\n- 방법1\n\nscore={'boram':49, 'iu':80}\nscore\n\n{'boram': 49, 'iu': 80}\n\n\n\ntype(score)\n\ndict\n\n\n- 방법2\n\nscore=dict(boram=49, iu=80)\nscore\n\n{'boram': 49, 'iu': 80}\n\n\n\ntype(score)\n\ndict\n\n\n- 방법3\n\n_lst= [['boram',40],['iu',80]] \n_lst\n\n[['boram', 40], ['iu', 80]]\n\n\n\ndict(_lst)\n\n{'boram': 40, 'iu': 80}\n\n\n- 방법4\n\n_tpl = ('boram',49),('iu',80)\n_tpl\n\n(('boram', 49), ('iu', 80))\n\n\n\ndict(_tpl)\n\n{'boram': 49, 'iu': 80}\n\n\n원소추출\n\nscore={'boram':49, 'iu':80}\nscore\n\n{'boram': 49, 'iu': 80}\n\n\nboram의 점수를 추출하고 싶다면?\n\nscore[0]   # 이렇게 ㄴㄴ \n\nKeyError: 0\n\n\n\nscore['boram']   # 위치번호가 아닌 key를 넣어야 한다.\n\n49\n\n\n- 리스트로 저장했다면?\n\nscore=[['boram',49],['iu',80]]\nscore\n\n[['boram', 49], ['iu', 80]]\n\n\n(방법1)\n\nscore[0][1]  # boram의 점수를 출력하란 의미 , 가독성이 떨어짐,\n\n49\n\n\n(방법2)\n\n_keys = [score[i][0] for i in range(len(score))]   #리스트컴프리헨션\n_keys\n\n['boram', 'iu']\n\n\n\n_values = [score[i][1] for i in range(len(score)) if score[i][0]=='boram']  \n_values\n\n[49]\n\n\n원소추가, 변경, 삭제\n\nscore={'boram':49, 'iu':80}\nscore\n\n{'boram': 49, 'iu': 80}\n\n\n- 추가\n\nscore['hynn']=99 # 추가\n\n\nscore\n\n{'boram': 49, 'iu': 80, 'hynn': 99}\n\n\n\nscore['boram']\n\n49\n\n\n- 변경\n\nscore['iu']=99   # 변경 ( 가변형)\nscore\n\n{'boram': 49, 'iu': 99, 'hynn': 99}\n\n\n\nscore\n\n{'boram': 49, 'iu': 99, 'hynn': 99}\n\n\n-삭제1\n\nscore={'boram':49, 'iu':80, 'hynn':99}\ndel score['boram']   # 삭제 방법 1\nscore\n\n{'iu': 80, 'hynn': 99}\n\n\n-삭제2\n\nscore={'boram':49, 'iu':80, 'hynn':99}\nscore.pop('boram')   # 삭제 방법 2\nscore\n\n{'iu': 80, 'hynn': 99}\n\n\n- 참고로 리스트였다면 이러한 삭제작업역시 비효율적이였을 것임\n\nscore = [['guebin',49],['iu',80],['hynn',99]] \nscore\n\n[['guebin', 49], ['iu', 80], ['hynn', 99]]\n\n\n\nscore = [[key,val] for key,val in score if key != 'guebin'] \nscore\n\n[['iu', 80], ['hynn', 99]]\n\n\n(숙제) 길이가 4인 dictionary를 생성 - len 함수를 이용하여 길이를 측정 - key를 이용하여 각 원소에 접근하여 보기\n\n_number = {'sung':2195, 'park':2836, 'choi':4236, 'kim':4738}\n_number\n\n{'sung': 2195, 'park': 2836, 'choi': 4236, 'kim': 4738}\n\n\n\nlen(_number)\n\n4\n\n\n\n_number['park']\n\n2836\n\n\n\n_number['choi']\n\n4236\n\n\n\n_number['jung']=4280\n\n\n_number\n\n{'sung': 2195, 'park': 2836, 'choi': 4236, 'kim': 4738, 'jung': 4280}\n\n\n\n_number.pop('kim')\n\n4738\n\n\n\n_number\n\n{'sung': 2195, 'park': 2836, 'choi': 4236, 'jung': 4280}"
  },
  {
    "objectID": "posts/python/python 4_0323.html",
    "href": "posts/python/python 4_0323.html",
    "title": "파이썬 4주차 (0323)",
    "section": "",
    "text": "연산\n- 하나있다.`\n\nscore={'boram':49, 'iu':80}\nscore\n\n{'boram': 49, 'iu': 80}\n\n\n\n'boram' in score\n\nTrue\n\n\n\n\n'iu' in score\n\nTrue\n\n\n\n'hynn' in score\n\nFalse\n\n\n- in은 사실 다른 자료형도 가능하다`\n(관찰1)\n\n'a' in 'boram'\n\nTrue\n\n\n\n'c' in 'boram'\n\nFalse\n\n\n(관찰2)\n\ntpl = 1,2,3\ntpl\n\n(1, 2, 3)\n\n\n\n1 in tpl\n\nTrue\n\n\n\n4 in tpl\n\nFalse\n\n\n(관찰3)\n\nscore=[['boram',49], ['iu',80]]\nscore\n\n[['boram', 49], ['iu', 80]]\n\n\n\n['boram', 49] in score\n\nTrue\n\n\n- in 연산자가 dict형에 사용되면 key를 기준으로 True, False을 판단한다.\n\n\n메소드\n(get)\n\nscore={'boram':49, 'iu':80}\nscore\n\n{'boram': 49, 'iu': 80}\n\n\n\nscore.get('boram')\n\n49\n\n\n아래와 같은 기능\n\nscore['boram']\n\n49\n\n\n미묘한 차이점이 존재함\n\nscore['hynn']  # hynn이 없어서 키에러 출력, 그런 key는 없다..\n\nKeyError: 'hynn'\n\n\n\nscore.get('hynn')  #hynn이 없으면 아무것도 출력안함\n\n(kyes, values, items)\n-.keys()는 딕셔너리의 키를 리턴한다.\n\nscore={'boram':49, 'iu':80}\nscore\n\n{'boram': 49, 'iu': 80}\n\n\n\n?score.keys\n\n\n_keys=score.keys()\n_keys\n\ndict_keys(['boram', 'iu'])\n\n\n\ntype(_keys)   # 모르는 자료형이지만, list나 tuple과 같이 자료형을 바꿀수 있다.\n\ndict_keys\n\n\n\nlist(_keys)  # 아무튼 그 이상한 자료형도 리스트화가 가능\n\n['boram', 'iu']\n\n\n-.values()는 딕셔너리의 키를 리턴한다.\n\n_values=score.values()\n_values\n\ndict_values([49, 80])\n\n\n\ntype(_values)\n\ndict_values\n\n\n\nlist(_values)\n\n[49, 80]\n\n\n-.items()는 딕셔너리의 키를 리턴한다.\n\n_items=score.items()\n_items\n\ndict_items([('boram', 49), ('iu', 80)])\n\n\n\ntype(_items)\n\ndict_items\n\n\n\nlist(_items)\n\n[('boram', 49), ('iu', 80)]\n\n\n- for문에서의 dict\n(예시1)\n\nfor i in score.keys():\n    print(i)\n\nboram\niu\n\n\n\nfor i in score:\n    print(i)\n\nboram\niu\n\n\n\n딕셔너리 그자체도 for문에 넣을 수 있다.\ni에는 value가 삭제되어 들어간다. (즉 key만)\n결과를 보면 score대신에 score.keys()와 list(score)를 넣었을때와 결과가 같다.\n\n\nNote: list(score)하면 key만 리턴된다.\n\n(예시2)\n\nfor i in score.values():\n    print(i)\n\n49\n80\n\n\n(예시3)\n\nfor k in score.items():\n    print(k)\n\n('boram', 49)\n('iu', 80)\n\n\n(예시4)\n\nfor i,j in score.items():\n    print(i,j)\n\nboram 49\niu 80\n\n\n(예시5)\n\nfor i,j in score.items():\n    print(i + '의 중간고사 점수는 %s점입니다' %j)\n\nboram의 중간고사 점수는 49점입니다\niu의 중간고사 점수는 80점입니다\n\n\n[보충학습] 문자열 새치기\n\n'제 이름은 %s입니다.'  % '김보람' \n\n'제 이름은 김보람입니다.'\n\n\n\n'제 이름은 %s입니다.'  % [1,2]\n\n'제 이름은 [1, 2]입니다.'\n\n\n\n1+1\n\n2\n\n\n\n[1,2]+[3,4]\n\n[1, 2, 3, 4]\n\n\n\n%는 새치기연산자임. %s는 새치기하는 자리라고 생각\n\n보충학습끝\n\n\n딕셔너리 고급\n키는 문자열만 가능한 것이 아니다.\n- 정수키\n\nscore = {0:49, 1:80, 1:99} # key를 0,1,2로\nscore\n\n{0: 49, 1: 99}\n\n\n- 인덱싱은?\n\nscore[0] # 키로 인덱싱을 하고 있는데 마치 원소의 위치로 인덱싱을 하는 기분\n\n49\n\n\n- 그럼 혹시 이것도?\n\nscore[:2]\n\nTypeError: unhashable type: 'slice'\n\n\n\nscore[-1]   # 될리가 없지..\n\nKeyError: -1\n\n\n- key로 가능한 것이 문자열만 가능한 것이 아니라 다른 것도 가능하다. (숫자,튜플,,)\n(예시)\n\nscore={(0,'boram'):49, (1, 'iu'):80, (2, 'hynn'):99}\nscore\n\n{(0, 'boram'): 49, (1, 'iu'): 80, (2, 'hynn'): 99}\n\n\n\nscore[(0,'boram')]\n\n49\n\n\n\nscore[0,'boram'] #tuple이니까 가로 생략 가능\n\n49\n\n\n(예시)\n\nscore={('boram',0):10, ('boram',1):20, ('boram',2):30} #0은 출석점수, 1은 레포트 점수, 2는 중간고사 점수\nscore\n\n{('boram', 0): 10, ('boram', 1): 20, ('boram', 2): 30}\n\n\n\nscore[('boram',0)]\n\n10\n\n\n\nscore['boram',0]\n\n10\n\n\n\nscore[('broam,3')] = 99  # 보람의 기말고사 점수를 추가\n\n\nscore\n\n{('boram', 0): 10, ('boram', 1): 20, ('boram', 2): 30, 'broam,3': 99}\n\n\n- 문자열, 숫자값, 튜플의 공통점? 불변객체\n\na=11\n\n\na=22  # 22로 수정된 것이 아니고 재할당된것임..\n\n\na\n\n22\n\n\n\na='boram'\n\n\na='Broam'\n\n\na  # 이것도 재할당..\n\n'Broam'\n\n\n\na[0]\n\n'B'\n\n\n\na[0]='b'  # 문자열 불변\n\nTypeError: 'str' object does not support item assignment\n\n\n\n# 수정이랑 재할당을 구분하는 방법 -> 메모리 주소 값을 찍어보면 된다.\n\n[참고로만]\n(인트형은 불변)\n\na=1\na, id(a)\n\n(1, 2254873389360)\n\n\n\na=2\na, id(a)\n\n(2, 2254873389392)\n\n\n(문자열도 불변)\n\na='boram'\na, id(a)\n\n('boram', 2254959000432)\n\n\n\na='Boram'\na, id(a)\n\n('Boram', 2254988509296)\n\n\n(리스트는 가변)\n\na=list('boram')\na, id(a)\n\n(['b', 'o', 'r', 'a', 'm'], 2254989018304)\n\n\n\na[0]='B'\n\n\na,id(a)   #id가 같다. 편집!\n\n(['B', 'o', 'r', 'a', 'm'], 2254989018304)\n\n\n\n\n집합\n\n선언\n\na={'notebook', 'desktop'}\n\n\n\n원소추출\n- 일단 인덱스로는 못한다.\n\na={'notebook', 'desktop'}\na[0]\n\nTypeError: 'set' object is not subscriptable\n\n\n- 딱히 하는 방법이 없다. 그리고 이걸 하는 의미가 없다. 원소에 접근해서 뭐하려고…!!\n원소추가\n- 이건 의미가 있다.\n\na={'notebook', 'desktop'}\n\n\na.add('ipad')\na\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\na.add('notebook') # 이미 원소로 있는 건 추가 되지 않음\na\n\n{'desktop', 'ipad', 'notebook'}\n\n\n원소삭제\n\na.remove('notebook')\na\n\n{'desktop', 'ipad'}\n\n\n연산\n- in 연산자\n\n1 in [1,2,3,4]\n\nTrue\n\n\n\n5 in [1,2,3,4]\n\nFalse\n\n\n\na=('desktop','ipad','notebook')\na\n\n('desktop', 'ipad', 'notebook')\n\n\n\n'notebook' in a\n\nTrue\n\n\n- 참고로 in 연산자는 집합에서만 쓰는 것은 아님\n- 합집합, 교집합, 차집합\n\nday1 = {'notebook', 'desktop'}\nday2 = {'notebook', 'ipad'}\n\n\nday1 | day2   # 합집합\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nday1 & day2 # 교집합\n\n{'notebook'}\n\n\n\nday1 - day2  # 차집합\n\n{'desktop'}\n\n\n\nday2 - day1\n\n{'ipad'}\n\n\n- 부분집합\n\nday1={'notebook','desktop'}\nday2= day1 | {'ipad'}\n\n\nday1\n\n{'desktop', 'notebook'}\n\n\n\nday2\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\nday1<day2   # day1는 day2의 부분집합인가?\n\nTrue\n\n\n\nday2<day1\n\nFalse\n\n\n메소드\n- 합집합\n\nday1= {'notebook','desktop'}\nday2 = {'notebook','ipad'}\n\n\nday1.union(day2)\n\n{'desktop', 'ipad', 'notebook'}\n\n\n\n# 나머지 메소드는 스스로 찾아보세용\n\nfor문\n\nday1= {'notebook','desktop'}\nday2 = {'notebook','ipad'}\n\n\nfor i in day1|day2:\n    print(i)\n\ndesktop\nipad\nnotebook\n\n\n(숙제) 길이가 4인 집합을 두개만들고 공통원소를 2개로 설정한 뒤 합집합을 구하는 코드를 작성하라.\n\nboram={'father','mother','me','coco'}\n\n\nlen(boram)\n\n4\n\n\n\nsu={'father','mother','su','name'}\n\n\nlen(su)\n\n4\n\n\n\nboram | su\n\n{'coco', 'father', 'me', 'mother', 'name', 'su'}"
  },
  {
    "objectID": "posts/python/python 4_0328.html",
    "href": "posts/python/python 4_0328.html",
    "title": "파이썬 4주차 (0328)",
    "section": "",
    "text": "강의영상\n\nyoutube: https://youtube.com/playlist?list=PLQqh36zP38-zcnjAged1xIatgznRTy93c\n\n- (1/8) 파이썬이 어려웠던 이유\n- (2/8) 1세대 프로그래머\n- (3/8) 1세대 프로그래머의 삶 with python\n- (4/8) 1세대 프로그래머의 삶 with ipython\n- (5/8) 2세대 프로그래머, 3세대 프로그래머 (1)\n- (6/8) 3세대 프로그래머(2), 4세대 프로그래머\n- (7/8) 5세대 프로그래머\n- (8/8) 다양한 개발환경 구축방법 다시 리뷰, 숙제설명\n\n\n파이썬이 어려웠던 이유\n- 파이썬 배우는 초보자에게 가장 어려운것!\n\n선생님마다 설치하는 방법이 모두 다름\n\n- 왜 저렇게 설치방법이 다른가? 왜 다른 방법으로 각각 파이썬을 실행하는가? 이런것이 너무 어려움\n\n방법1: 파이썬프로그램 다운로드 -> 시작버튼 눌러서 설치\n방법2: 아나콘다 설치 (그럼 자동으로 파이썬이 설치됨)\n방법3: 아나콘다 설치 + 가상환경\n…\n\n- 심지어 실행하는것도 다름\n\n방법1: 파이썬 프롬프트\n방법2: .py를 이용하여 실행?\n방법3: IDLE\n방법4: 파이참\n방법5: 스파이더\n방법6: Visual Studio Code\n방법7: 주피터노트북, 주피터랩\n\n가상환경을 만들어서 해라..\n아나콘다 네비게이터에 주피터가 있다..\n\n…\n\n- 머리아프니까 collab을 쓰라는 사람도 있음. 아니면 도커이미지를 줄테니까 그걸 쓰라는 사람도 있음. AWS를 쓰라는 사람도 있음.. \\(\\to\\) 이게 더 머리아픔\n- 핵심: 그냥 (1) 컴퓨터에 (2) 파이썬을 깔아서 (3) 실행하는 것임\n- 의문: 그런데 방법이 왜이렇게 많은가? 엑셀처럼 프로그램 설치하고 아이콘 더블클릭하면 끝나는 식으로 만들어야 하는것 아닌가?\n\n개발환경 구축방법이 많은 이유?\n- 파이썬 개발환경 구축은 수많은 방법이 있다.\n- 이는 마치 라면의 레시피를 검색하면 수많은 방법이 나오는것과 유사함.\n\n방법1: 스프를 먼저 넣고 끓인다음 라면을 넣어야 합니다.\n방법2: 양은냄비에 물넣고 물이 끊으면 라면과 스프를 같이 넣고 마지막에 계란을 넣는다.\n방법3: 먹다남은 삼겹살을 후라이팬에 볶은다음에 물을 붓고 라면을 넣는다.\n방법4: 용기에 라면+스프+뜨거운물 랩을 씌운뒤에 젓가락으로 구멍을 뚫고 전자렌지에 돌린다.\n…\n\n- 우리는 모든 방법을 나열할 순 없지만 모든 방법을 이해할 수 있다. 왜냐하면 라면을 끓이는 공통적인 맥락을 우리는 알고 있으니까\n- 파이썬을 설치하는 다양한 방법 역시 공통맥락을 파악하면 이해하기 쉽다.\n- 제목적: 파이썬을 설치하고 실행하는 공통맥락을 설명하고 싶음\n- 설치하는 방법이 다양한 이유? 파이썬이 인기있음 + 다양한 방법을 설치를 하면 각자의 장점이 뚜렷해서\n\n\n\n1세대 프로그래머\n\npython\n- 윈도우에서 anaconda prompt 실행 -> python\n(base) C:\\Users\\python>python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> [1,2,3]+[4]\n[1, 2, 3, 4]\n>>> a=[1,2,3]+[4]\n>>> a\n[1, 2, 3, 4]\n- 2개를 실행할 수도 있음. (두 환경은 각각 서로 독립적인 파이썬, 변수가 공유되지 않음) \\(\\star\\)\n- 아쉬운점: `?list’와 같이 도움말 기능이 동작하지 않음\n>>> ?list\n  File \"<stdin>\", line 1\n    ?list\n    ^\nSyntaxError: invalid syntax\n>>> \n\n\nipython\n- 윈도우에서 anaconda prompt 실행 -> ipython\n(base) C:\\Users\\python>ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: a=[1,2,3]\n\nIn [2]: a\nOut[2]: [1, 2, 3]\n\nIn [3]: a+[4]\nOut[3]: [1, 2, 3, 4]\n- ?list가 가능\nIn [4]: ?list\nInit signature: list(iterable=(), /)\nDocstring:\nBuilt-in mutable sequence.\n\nIf no argument is given, the constructor creates a new empty list.\nThe argument must be an iterable if specified.\nType:           type\nSubclasses:     _HashedSeq, StackSummary, DeferredConfigList, SList, _ImmutableLineList, FormattedText, NodeList, _ExplodedList, Stack, _Accumulator, ...\n\n- 색깔이 알록달록해서 문법을 보기 편하다. (구문강조)\n\n\n1세대 프로그래머의 삶 with python\n- 1부터 10까지 합을 구하는 프로그램을 만들고 싶음\n- 시도1: python을 키고 아래와 같이 실행\n(base) C:\\Users\\python>python\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> total = 0\n>>> for i in range(10):\n...     total=total+i\n...\n>>> total\n45\n>>>\n- 반성: 정답은 55인데 45가 출력되었다! \\(\\to\\) range(10)을 range(1,11)으로 바꿔야겠다!\n- 시도2: range(1,11)을 바꿔야겠다고 생각하고 다시 입력하다가 오타가 발생\n>>> total =0\n>>> for i in range(1,11):\n...     total = totla +i\n...\n\n앗 totla이라고 잘못쳤다.\n\n- 반성: 다음에는 정신을 똑바로 차려야겠다.\n- 불편한점: … 다..\n\n\n1세대 프로그래머의 삶 with ipython\n- ipython을 사용한 프로그래머는 좀더 상황이 낫다\n(base) C:\\Users\\python>ipython\nPython 3.9.7 (default, Sep 16 2021, 16:59:28) [MSC v.1916 64 bit (AMD64)]\nType 'copyright', 'credits' or 'license' for more information\nIPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.\n\nIn [1]: total = 0\n\nIn [2]: for i in range(1,11):\n   ...:     total = total + i\n   ...:\n\nIn [3]: total\nOut[3]: 55\n\n편한점1: 자동으로 들여쓰기가 되어서 편함\n편한점2: 화살표를 이용해서 for문을 쓰는 도중에 위아래로 이동가능\n불편한점1: 화살표로 이동할수는 있는데 마우스로는 이동할 수 없다.\n불편한점2: 내가 작성한 코드를 관리하기 어렵다.\n\n\n\n\n2세대 프로그래머: 메모장 + anconda prompt를 이용 (.py를 이용한 python활용)\n- 메모장을 키고 아래의 내용을 적는다.\ntotal = 0 \nfor i in range(1,11): \n    total = total + i\nprint(total)\n- 파일이름을 mysum.py로 저장한다.\n- anaconda prompt에서 mysum.py파일이 저장된 폴더로 이동 -> 실행\n(base) C:\\Users\\python>cd Desktop\n\n(base) C:\\Users\\python\\Desktop>dir\n C 드라이브의 볼륨에는 이름이 없습니다.\n 볼륨 일련 번호: 9AFD-A05F\n\n C:\\Users\\python\\Desktop 디렉터리\n\n2022-03-27  오전 11:32    <DIR>          .\n2022-03-27  오전 11:32    <DIR>          ..\n2022-03-27  오전 12:01             2,306 Chrome.lnk\n2022-03-26  오후 08:32             2,332 Microsoft Edge.lnk\n2022-03-27  오전 11:33                71 mysum.py\n               3개 파일               4,709 바이트\n               2개 디렉터리  743,643,467,776 바이트 남음\n\n(base) C:\\Users\\python\\Desktop>python mysum.py\n55\n\n(base) C:\\Users\\python\\Desktop>\n- 소감 - 편한점1: 마우스를 이용하여 이동가능 - 편한점2: 내가 작업한 내용은 바탕화면의 메모장에 저장이 되어있음 - 아쉬운점: ipython의 장점은 활용못함 (구문강조, 도움말기능)\n\n\n3세대 프로그래머: 메모장 + ipython\n- 전체적인 개발방식 - 메모장: 코드를 편집, 저장 - ipython: anaconda prompt처럼 메모장의 코드를 실행하고 결과를 확인 + 구문강조, 도움말확인기능 등을 이용하여 짧은 코드를 빠르게 작성\n- 기능 - ipython에서 !python mysum.py를 입력하면 anaconda prompt에서 python mysum.py를 입력한 것과 같은 효과 - ipython에서 %run mysum을 입력하면 메모장에서 mysum.py에 입력된 내용을 복사해서 ipython에 붙여넣어 실행한것과 같은 효과\n\n\n4세대 프로그래머: IDE(통합개발환경)를 사용\n- 메모장과 ipython을 하나로 통합한 프로그램이 등장! - jupyter notebook, jupyter lab - spyder - idle - VScode - …\n- 주피터의 트릭 (실제로 주피터는 ipython에 기생할 뿐 아무런 역할도 안해요)\n\n주피터를 실행\n새노트북을 생성 (파이썬으로 선택)\n\n\n컴퓨터는 내부적으로 ipython을 실행하고 그 ipython이랑 여러분이 방금만든 그 노트북과 연결\n\n\n처음보이는 cell에 1+1을 입력 -> 쉬프트엔터 -> 결과2가 출력\n\n\n처음보이는 cell하나 = 자동으로 열린 하나의 메모장\ncell 1+1을 입력 = 메모장에 1+1을 적음\n쉬프트+엔터후 결과2를 출력 = cell의 내용을 복사 -> ipython에 붙여넣음 -> ipython 계산된 결과를 복사 -> cell로 돌아와 붙여넣기\n\n\n새로운 cell을 추가하고 2+2을 입력 -> 쉬프트엔터 -> 결과4가 출력\n\n\n새로운 cell을 추가 = 새로운 메모장 추가\ncell 2+2을 입력 = 새로운 메모장에 2+2를 적음\n쉬프트+엔터후 결과4를 출력 = cell의 내용을 복사 -> ipython에 붙여넣음 -> ipython 계산된 결과를 복사 -> cell로 돌아와 붙여넣기\n\n- 중요한 사실들 - IDE는 내부적으로 연산을 수행하는 능력이 없다. (생각해볼것: 왜 R을 꼭 설치하고 Rstudio를 설치해야 했을까?)\n\n주피터에서 커널을 재시작한다는 의미는 메모장이 열린채로 ipython을 껐다가 다시 실행한다는 의미\n주피터는 단순히 ’메모장의 내용을 복사하여 붙여넣는 기계’라고 볼 수 있다. 이렇게 생각하면 주피터는 꼭 ipython에 연결할 이유는 없다. 실제로 주피터에 R을 연결해서 쓸 수 있다. 즉 하나의 IDE가 여러개의 언어와 연결될 수 있다.\nJupyterlab이라는 프로그램은 크롬에 있는 내용과 ipython간의 통신을 제어하는 프로그램일 뿐이다.\n\n\n\n5세대 프로그래머: 가상컴퓨터(anaconda), 원격컴퓨터(server), 클라우드컴퓨터(colab)의 개념 등장\n- 지금까지는 ipython이 실행되는 컴퓨터와 크롬이 실행되는 컴퓨터가 동일하다는 전제였음.\n- 생각해보니까 어차피 ipython이 실행된 컴퓨터에서 내가 크롬에 입력한 명령 “전달”되기만 하면 되므로 꼭 같은 컴퓨터일 필요는 없다.\n\n모델1: 원격컴퓨터\n- 준비상태 - 전북대컴퓨터: ipython을 실행 + 이 컴퓨터는 인터넷 연결이 되어있어야함 - 우리집노트북: 크롬실행 + 이 컴퓨터도 인터넷이 연결되어 있어야함\n- 명령입력 - 우리집노트북 크롬에서 1+1을 입력하고 쉬프트 엔터를 누름\n- 우리집노트북 -> 전북대컴퓨터 - 우리집 노트북의 내부의 어떤프로그램은 1+1이라는 명령을 복사하여 카카오톡으로 전북대 컴퓨터에 전달 - 전북대 컴퓨터의 내부의 어떤프로그램은 1+1이라는 명령을 카톡으로 받아서 그것을 ipython에게 전달\n- 전북대컴퓨터 -> 우리집노트북 - 전북대컴퓨터 내부의 ipython은 2라는 출력결과를 계산함 - 전북대컴퓨터 내부의 어떤프로그램은 계산결과를 카톡으로 우리집 노트북에 알려줌 - 나는 우리집 노트북에서 계산결과를 받아볼 수 있다.\n\n\n모델2: 원격컴퓨터 + 가상컴퓨터\n- 준비상태 - 성능좋은 전북대 컴퓨터 1개 - 내 노트북 1개 (그냥 싸고 가벼운거) - 대학원생 아이패드 1개 (그냥 싸고 가벼운거)\n- 아이디어\n\n성능좋은 전북대 컴퓨터를 논리적으로 3개로 분리 \\(\\to\\) 이를 각각 (base) (py39jl17) (py38r40) 컴퓨터라고 하자.\n나는 (py39jl17)에 접속하여 파이썬 3.9와 줄리아 1.7을 설치한뒤 실습한다.\n대학원생은 (py38r40)에 접속하여 파이썬 3.8과 R 4.0을 설치하고 실습한다.\n(base)는 예비용으로 아무것도 설치안한 깨끗한 상태 유지\n내가 뭘 실수해서 (py39jl17)컴퓨터가 망가졌으나 (py38r40)은 아무 타격없다.\n나는 (py39jl17)를 삭제하고 (base)로 부터 다시 새로운 컴퓨터를 복사하여 (py39jl17)을 다시 만든다.\n\n\n\n모델3: 가상컴퓨터\n- 여러분들 사례\n\n여러분들의 컴퓨터는 (base), (py39) 2개의 컴퓨터로 나누어져 있음\n여러분들이 (py39)에만 주피터랩을 설치\n(py39)에 있는 ipython과 여러분의 크롬창이 서로 통신하면서 실습\n장점: 서로 다른 환경에 서로다른 파이썬과 R등을 설치할 수 있다. \\(\\to\\) 패키지간의 충돌이 최소화 (파이썬 입문 수업을 듣고, 이후에 파이썬을 이용하는 어떤수업을 들음)\n\n\n\n모델4: 클라우드\n- 사례1 - 성능이 그저그런 컴퓨터 27개 - 대학원생을 포함하여 쓸 사람은 5명 - 한사람당 27/5(=5.4)대의 컴퓨터식 할당\n- 사례2: 구글코랩 - 구글에 여러가지 성능을 가진 컴퓨터가 \\(n\\)대 있음 - \\(m\\)명의 사람이 \\(n\\)대의 컴퓨터에 접속 - 적당히 컴퓨터 자언을 분배하여 사용\n\n\n\n요약 및 정리\n- 결국 (1) 컴퓨터에 (2) 파이썬을 설치하고 (3) 실행하는 과정은 생각보다 다양한 선택의 조합이 가능하다.\n\n그냥 내 노트북에 파이썬을 설치할지? 내 노트북안에 가상컴퓨터를 만들고 거기에 파이썬을 설치할지? 학교의 데스크탑에 파이썬을 설치하고 쓸지? 설치를 안하고 구글컴퓨터에 설치된 파이썬을 난 쓰기만 할지?\npython설치할지? ipython를 설치할지? 어차피 가상환경을 쓸꺼니가 anaconda를 설치할지? 아니면 코랩쓸꺼니까 설치안할지?\n어떤 IDE를 쓸지? IDE를 쓰지 않을지? 내가 IDE를 직접구성해서 만들지?\n\n하지만 공통적으로 관통하는 원리가 있다\n\n\n숙제\n- 주피터랩에서 ’myprod.py’파일을 만들고 1부터 5까지의 곱을 계산하는 코드를 작성후 %run myprod를 실행하여 출력결과를 확인\n\n%run myprod\n\n120"
  },
  {
    "objectID": "posts/python/python 7_0413.html",
    "href": "posts/python/python 7_0413.html",
    "title": "파이썬 7주차 (0413)",
    "section": "",
    "text": "import numpy as np"
  },
  {
    "objectID": "posts/python/python 7_0413.html#numpy공부-5단계-랜덤모듈",
    "href": "posts/python/python 7_0413.html#numpy공부-5단계-랜덤모듈",
    "title": "파이썬 7주차 (0413)",
    "section": "numpy공부 5단계 : 랜덤모듈",
    "text": "numpy공부 5단계 : 랜덤모듈\n\nnp.random.rand()\n- 0~1사이에서 10개의 난수 생성\n\nnp.random.rand(10)\n\narray([0.30133684, 0.33047977, 0.37682904, 0.34945581, 0.88634262,\n       0.272207  , 0.75103749, 0.55871507, 0.12304257, 0.88020941])\n\n\n- 0~2사이에서 10개의 난수 생성\n\nnp.random.rand(10)*2\n\narray([1.85950286, 0.90618509, 0.3153    , 0.47472741, 1.60545103,\n       1.07072774, 1.10650141, 0.77505785, 1.19933414, 1.76222208])\n\n\n- 1~2사이에서 10개의 난수 생성\n\nnp.random.rand(10)+1\n\narray([1.01747795, 1.52789889, 1.29223002, 1.53147587, 1.13455031,\n       1.51668185, 1.2430438 , 1.59676278, 1.8731811 , 1.36113831])\n\n\n- 1~3사이에서 10개의 난수 생성\n\nnp.random.rand(10)*2+1    # 1~3\n\narray([2.79324839, 2.37177079, 1.12638737, 1.71767497, 2.95057073,\n       1.23158048, 2.56688411, 2.94392262, 1.32675882, 2.29817471])\n\n\n\n\nnp.random.randn()\n- N(0,1) 에서 10개 추출\n\nnp.random.randn(10) # 표준정규분포에서 10개의 샘플 추출\n\narray([ 1.895967  , -0.26215342,  0.87906492,  0.45616171,  1.66244424,\n        0.72458419,  0.31057676, -0.55909889,  0.47656554,  0.35143513])\n\n\n- N(1,1)에서 10개 추출\n\nnp.random.randn(10)+1\n\narray([ 1.11007188, -0.44321876,  0.04904333, -0.10478302,  0.13301967,\n       -0.49468263,  1.7751611 , -0.84760291,  0.40840343,  0.638133  ])\n\n\n- N(0,4)에서 10개 추출 (평균이 0이고 분산이 4인 분포)\n\nnp.random.randn(10)*2\n\narray([-1.14364925,  2.60415043, -1.65488974, -0.59463897,  0.97607708,\n        2.33979589,  3.49290763, -1.50749403, -1.41447157,  0.45852112])\n\n\n- N(3,4)에서 10개 추출\n\nnp.random.randn(10)*2+3\n\narray([ 4.736406  ,  2.35419865,  2.8265146 ,  0.26470966, -0.4240817 ,\n        1.00836216,  6.23531314,  3.75134991,  0.60427655, -0.13645246])\n\n\n\n\nnp.random.randint()\n- [0,7)의 범위에서 하나의 정수를 랜덤으로 생성\n\nnp.random.randint(7)   #[0,7)의 범위에서 하나의 정수 생성\n\n3\n\n\n- [0,7)의 범위에서 20개의 정수를 랜덤으로 생성\n\nnp.random.randint(7,size=(20,))  # [0,7)의 범위에서 20개의 정수 생성\n\narray([2, 5, 5, 5, 2, 4, 3, 4, 1, 4, 1, 2, 3, 2, 4, 2, 2, 6, 1, 2])\n\n\n- [0,7)의 범우에서 (5,5) shape으로 정수를 랜덤으로 생성\n\nnp.random.randint(7,size=(5,5))  \n\narray([[1, 6, 2, 5, 0],\n       [3, 3, 3, 1, 0],\n       [4, 0, 2, 5, 6],\n       [1, 0, 1, 2, 0],\n       [6, 6, 5, 1, 3]])\n\n\n- 위와 같은 코드를 아래와 같이 구현가능\n\nnp.random.randint(low=7,size=(2,2))  # [0,7)의 범위에서 20개의 정수 생성\n\narray([[2, 4],\n       [6, 4]])\n\n\n- [10,20)의 범위에서 (5,5) shape 정수를 랜덤으로 생성\n\nnp.random.randint(low=10, high=20,size=(5,5))  \n\narray([[14, 19, 17, 14, 17],\n       [16, 11, 14, 17, 16],\n       [12, 11, 18, 17, 14],\n       [11, 15, 14, 18, 11],\n       [13, 19, 10, 17, 14]])\n\n\n- 의문: np.random.randint(low=7,size=(5,5)) 가 좀 이상하다. 사실 np.random.randint(high=7,size=(5,5))가 되어야 맞지 않는가?\n-> 저도 그렇게 생각하긴 하는데요, 구현이 이렇게 되어있습니다. 도움말 확인!\nReturn random integers from the \"discrete uniform\" distribution of the specified dtype in the \"half-open\" interval [`low`, `high`). If `high` is None (the default), then results are from [0, `low`).\n\n\nnp.random.choice()\n- ver1\n\nnp.random.choice(5,20)  # [0,5)에서 20개를 뽑음, 중복허용\n\narray([3, 2, 0, 3, 3, 3, 0, 0, 2, 2, 0, 0, 0, 1, 3, 1, 3, 2, 0, 0])\n\n\n\nnp.random.randint(5, size=(20,))\n\narray([3, 2, 2, 3, 4, 1, 0, 1, 4, 1, 3, 2, 2, 2, 4, 3, 2, 4, 2, 3])\n\n\n- ver2\n\nnp.random.choice([0,1,2,3],20) # [0,1,2,3] 에서 20개를 뽑음 , 중복허용\n\narray([2, 0, 1, 3, 1, 1, 2, 2, 1, 2, 0, 1, 1, 0, 1, 0, 2, 3, 3, 1])\n\n\n\nnp.random.choice([\"apple\",\"orange\",\"banana\"],20)\n\narray(['orange', 'banana', 'banana', 'orange', 'banana', 'orange',\n       'banana', 'orange', 'apple', 'orange', 'orange', 'apple', 'apple',\n       'orange', 'apple', 'apple', 'orange', 'orange', 'apple', 'apple'],\n      dtype='<U6')\n\n\n\nnp.random.choice([\"apple\",\"orange\",\"banana\"],2,replace=False) # 중복허용 X \n\narray(['apple', 'orange'], dtype='<U6')\n\n\n\n\n통계분포\n\nnp.random.binomial(n=10, p=0.1, size=(5,)) #X1, ..., X5 ~ B(10,0.2)\n\narray([1, 0, 2, 0, 2])\n\n\n\nnp.random.normal(loc=10,scale=2,size=(5,)) # X1, ..., X5 ~ N(10,4) \n\narray([8.5617943 , 8.9716337 , 7.90650741, 6.59782362, 7.90620931])\n\n\n\nnp.radom.randn(5)*2 + 10와 같은코드\n\n\nnp.random.uniform(low=2,high=4,size=(5,)) # X1, ..., X5 ~ U(2,4)  #균일분포\n\narray([2.49501161, 3.10469251, 3.89920656, 2.33160764, 2.28406983])\n\n\n\nnp.random.rand(5)*2+2와 같은 코드\n\n\nnp.random.poisson(lam=5,size=(5,)) # X1,...,X5 ~ Poi(5) \n\narray([5, 5, 7, 4, 6])"
  },
  {
    "objectID": "posts/python/python 7_0413.html#nupmy공부-6단계-기타-유용한-기본기능들",
    "href": "posts/python/python 7_0413.html#nupmy공부-6단계-기타-유용한-기본기능들",
    "title": "파이썬 7주차 (0413)",
    "section": "nupmy공부 6단계: 기타 유용한 기본기능들",
    "text": "nupmy공부 6단계: 기타 유용한 기본기능들\n\nnp.where, np.argwhere\n\na=np.array([0,0,0,1,0])\na\n\narray([0, 0, 0, 1, 0])\n\n\n\nnp.where(a==1) # 조건 a==1을 만족하는 인덱스를 출력하라\n\n(array([3], dtype=int64),)\n\n\n\nnp.argwhere(a==1)\n\narray([[3]], dtype=int64)\n\n\n\nnp.argwhere(a==0)\n\narray([[0],\n       [1],\n       [2],\n       [4]], dtype=int64)\n\n\n- 2차원\n\nnp.random.seed(43052)\na=np.random.randn(12).reshape(3,4)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a<0) # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미\n\n(array([1, 1, 2, 2, 2], dtype=int64), array([2, 3, 0, 1, 3], dtype=int64))\n\n\n\nnp.argwhere(a<0)  # 조건을 만족하는 인덱스가 (1,2), (1,3), (2,0), (2,1), (2,3) 이라는 의미\n\narray([[1, 2],\n       [1, 3],\n       [2, 0],\n       [2, 1],\n       [2, 3]], dtype=int64)\n\n\n\na[np.where(a<0)]  # 조건을 만족하는 인덱스가 모두 출력=> 1차원 array로 출력\n\narray([-1.66307542, -1.38277318, -1.92684484, -1.4862163 , -0.03488725])\n\n\n\na[np.argwhere(a<0)]  # 출력불가능\n\nIndexError: index 3 is out of bounds for axis 0 with size 3\n\n\n\na[np.argwhere(a<0)[0][0],np.argwhere(a<0)[0][1]] # 어거지로 출력할수는 있음 \n\n-1.6630754187023522\n\n\n- np.where의 특수기능\n\nnp.random.seed(43052)\na=np.random.randn(12).reshape(3,4)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368],\n       [ 0.23778744,  0.35595116, -1.66307542, -1.38277318],\n       [-1.92684484, -1.4862163 ,  0.00692519, -0.03488725]])\n\n\n\nnp.where(a<0,0,a)   #a<0을 체크=> 조건에 맞으면 0, 조건에 안맞으면 a 출력\n\narray([[0.38342049, 1.0841745 , 1.14277825, 0.30789368],\n       [0.23778744, 0.35595116, 0.        , 0.        ],\n       [0.        , 0.        , 0.00692519, 0.        ]])\n\n\n\nnp.where(a<0,0,1) # #a<0을 체크=> 조건에 맞으면 0, 조건에 안맞으면 1 출력\n\narray([[1, 1, 1, 1],\n       [1, 1, 0, 0],\n       [0, 0, 1, 0]])\n\n\n- 요약 - np.where : 인덱스의 좌표를 읽는 가독성은 떨어짐. 그러나 조건에 맞는 원소를 출력하거나 조건에 맞는 특수기능을 처리하는 목적으로 좋은 함수 - np.argwhere : 인덱스의 좌표를 읽는 가독성은 좋은 편임. 그러나 조건에 맞는 원소를 출력하거나 처리하는 기능은 떨어짐\n\n\n인덱싱고급\n- 원래 a는 2d array\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n- 경우 1: 인덱싱 결과가 1d array로 나올 수 있음\n\na[0,:] # 인덱싱의 결과 축의 갯수가 바뀐다. 2d array -> 1d array\n\narray([0, 1, 2, 3])\n\n\n- 경우2: 인덱싱 결과가 2d array로 나올 수 있음\n\na[[0,1],:] # 이것은 축의 숫자가 유지됨 2d array-> 2d array\n\narray([[0, 1, 2, 3],\n       [4, 5, 6, 7]])\n\n\n- 경우1의 상황에서도 축의 갯수를 유지하면서 인덱싱하려면?\n\na[[0],:] # 인덱싱의 결과 축의 갯수가 유지된다. 2d array->2d array\n\narray([[0, 1, 2, 3]])\n\n\n- 미묘한 차이를 이해할 것\n\na[:,0], a[:,[0]]\n\n(array([0, 4, 8]),\n array([[0],\n        [4],\n        [8]]))\n\n\n\n\nnp.ix_\n- 아래의 인덱싱을 비교하자\n\na=np.arange(12).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\na[0:2,0:2]\n\narray([[0, 1],\n       [4, 5]])\n\n\n\na[[0,1],0:2]\n\narray([[0, 1],\n       [4, 5]])\n\n\n\na[0:2,[0,1]]\n\narray([[0, 1],\n       [4, 5]])\n\n\n- 언뜻 생각하면 위의 결과와 a[[0,1],[0,1]의 결과가 동일할 것 같다.\n\na[[0,1],[0,1]]\n\narray([0, 5])\n\n\n\n실제로는 [a[0,0],a[1,1]]이 array로 나옴\n\n- 사실 np.where에서 이미 관찰하였음\n\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\nnp.where(a % 5 ==0)\n\n(array([0, 1, 2], dtype=int64), array([0, 1, 2], dtype=int64))\n\n\n\na[np.where(a % 5 ==0)]\n\narray([ 0,  5, 10])\n\n\n\na[[0, 1, 2],[0, 1, 2]]\n\narray([ 0,  5, 10])\n\n\n- a[[0,1],[0,1]]이 a[0:2,0:2]를 의미하게 하려면 아래와 같이 하면 된다.\n\na[np.ix_([0,1],[0,1])] # 유용해보이지만 생각보다 잘 쓰이는건 아님 \n\narray([[0, 1],\n       [4, 5]])\n\n\n(숙제)\n\nnp.random.uniform(low=1.3,high=1.7,size=(10,))\n\narray([1.65411132, 1.42531485, 1.54567744, 1.44735207, 1.33217747,\n       1.48856969, 1.47329978, 1.38976795, 1.30469965, 1.66634909])\n\n\n위와 같은코드를 np.random.rand()를 이용하여 구현하라."
  },
  {
    "objectID": "posts/python/python 2_0314.html",
    "href": "posts/python/python 2_0314.html",
    "title": "파이썬 2주차 (0314)",
    "section": "",
    "text": "- 리스트의 선언\n\na=[11,22]\na\n\n[11, 22]\n\n\n\ntype(a)\n\nlist\n\n\n- 비어있는 리스트의 선언\n\na=[] # 방법1\na\n\n[]\n\n\n\na=list() # 방법2\na\n\n[]\n\n\n\n\n\n- 더하기연산\n\na=[11,22]\nb=[12,13]\n\n\na\n\n[11, 22]\n\n\n\nb\n\n[12, 13]\n\n\n\na+b\n\n[11, 22, 12, 13]\n\n\n\n우리의 예상과 다른 결과가 나옴 \\(\\to\\) 파이썬은 R처럼 자체적으로 좋은 계산기능을 내장하고 있찌 않음\n\n- 브로드캐스팅과 같이 R에서는 당연히 가능했던 기능을 사용할 수 없음\n\na=[1,2,3]\nb=1\na+b\n\nTypeError: can only concatenate list (not \"int\") to list\n\n\n- 뺄셈은 정의되지 않음\n\na=[1,2]\nb=[1,2]\na-b\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n- 곱하기는 정의 가능\n\na=[1,2]\n\n\n2*a  #a+a\n\n[1, 2, 1, 2]\n\n\n- 나눗셈은 정의되지 않음\n\na=[1,2,1,2]\na/2\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n- 더하기와 곱하기는 원소의 추가와 반복추가를 의미하지만 그렇다고 해서 뺄샘과 나눗셈이 원소의 삭제를 의미하는 것은 아님\n\na=[1,2,3]\na-[3]   #이런건없다\n\nTypeError: unsupported operand type(s) for -: 'list' and 'list'\n\n\n\na=[1,2,1,2,1,2,]\na/3    # 이런건없다\n\nTypeError: unsupported operand type(s) for /: 'list' and 'int'\n\n\n- 더하기와 곱하기가 원소의 추가와 반복추가를 의미하여 편리할때도 있긴하지만, 우리는 산술적인 +, *를 원하는 경우도 있다. 이럴 경우는 어떻게 할 수 있을까?\n(예제)\n\na=[1,2]\nb=[3,4]\n\na+b=[4,6]이 되도록 하려면?\n(풀이1)\n\ntype(a)\n\nlist\n\n\n\ntype(a[0])\n\nint\n\n\n\na[0]+b[0]  #a의 첫번째 원소 추출, b의 첫번째 원소 추출, 둘을 더함\n\n4\n\n\n\na[1]+b[1]\n\n6\n\n\n\n[a[0]+b[0], a[1]+b[1]]\n\n[4, 6]\n\n\n풀이가 가능한 이유? a,b는 리스트이지만 a[0], a[1], b[0], b[1]은 각각 인트형임. 인트형은 +연산이 가능함\n(풀이2)\nnumpy패키지 (파이썬의 여러 수치연산들을 담당하는 라이브러리) - 이러한 벡터연산은 누구나 필요로 하는 연산 - 내가 아니더라도 누군가가 프로그램화 해놓았을 것임 - 그 누군가가 자신이 만든 코드를 잘 정리하여 무료로 배포했을 수도 있음 (패키지를 배포한다고 표현) - 그 패키지를 가져와서 설치한 뒤 사용하기만 하면 된다.\n패키지를 설치하는 방법 - !pip install numpy # 최신버전을 설치함 - !conda install -c conda-forge numpy -y # 안전한 버전을 설치함\n설치된 패키지를 사용하는 방법 - import numpy 한뒤에 numpy.??로 기능을 사용 - import numpy as np 한뒤에 np.??로 기능을 사용\n파이썬의 기본 패키지 numpy pandas matplotlib\n\n!pip install numpy\n\nRequirement already satisfied: numpy in c:\\users\\user\\anaconda3\\lib\\site-packages (1.21.5)\n\n\n\nimport numpy # 설치한 패키지를 쓰겠다고 선언함 library(tidyverse)와 비슷.\n\n\na=[1,2]\nb=[3,4]\n\n\na+b\n\n[1, 2, 3, 4]\n\n\n\ntype(numpy.array(a))\n\nnumpy.ndarray\n\n\n\naa=numpy.array(a)   #aa는 리스트가 아니라 넘파이 어레이, numpy.array()는 numpy패키지에서 제공하는 array함수를 쓰겠다는 의미\nbb=numpy.array(b)   \n\n\naa+bb\n\narray([4, 6])\n\n\n\na+b\n\n[1, 2, 3, 4]\n\n\n이런것도 가능\n\n2*aa+1\n\narray([3, 5])\n\n\n\n2*aa+1+bb\n\narray([6, 9])\n\n\n(풀이3)\n\nimport numpy as np # 설치한 numpy라는 패키지를 쓰겠음. 그런데 numpy 말고 np라는 이름으로 쓰겠음\n\n\nnp.array(a)+np.array(b)\n\narray([4, 6])\n\n\n\n\n\n- str형과 동일한 방식\n\na=[11,22,33,44,55]\n\n\na[0:3]\n\n[11, 22, 33]"
  },
  {
    "objectID": "posts/python/python 2_0314.html#콘테이너형-객체-가변객체",
    "href": "posts/python/python 2_0314.html#콘테이너형-객체-가변객체",
    "title": "파이썬 2주차 (0314)",
    "section": "콘테이너형 객체, 가변객체",
    "text": "콘테이너형 객체, 가변객체\n- 객체 - Object - Something\n- 리스트의 원소는 int, float따위만 가능한 것이 아니다. (리스트는 콘테이너형 객체이므로)\n\nlst = [1,3.14,True, 'a', [1,2],\n      (1,2), {'name':'iu','age':30},{1,2,3}]\n\n\nlst\n\n[1, 3.14, True, 'a', [1, 2], (1, 2), {'name': 'iu', 'age': 30}, {1, 2, 3}]\n\n\n각 원소의 타입을 알아보자\n\ntype(lst[0])\n\nint\n\n\n\ntype(lst[1])\n\nfloat\n\n\n\ntype(lst[2])\n\nbool\n\n\n\ntype(lst[3])\n\nstr\n\n\n\ntype(lst[4])\n\nlist\n\n\n\ntype(lst[5])\n\ntuple\n\n\n\ntype(lst[6])   # dictionary\n\ndict\n\n\n\ntype(lst[7]) #집합\n\nset\n\n\n- str은 컨테이너형이 아니다\n\n# 컨테이너형이 아닌것\n'abcd'[0]\n\n'a'\n\n\n\nstr의 모든 원소는 문자임\n\n- 리스트의 원소를 수정할 수 있다. (리스트는 가변객체이므로)\n\na=[11,22,33]\n\n\na[0]\n\n11\n\n\n\na[0]=111\n\n\na\n\n[111, 22, 33]\n\n\n- 원소수정은 당연한 기능 같은데 이것이 불가능한 경우도 있다.\n(가능한경우)\n\n'boram'[1]\n\n'o'\n\n\n\na=['b','o','r','a','m']\n\n\na[0]\n\n'b'\n\n\n\na[0]='B'\n\n\na\n\n['B', 'o', 'r', 'a', 'm']\n\n\n(불가능한경우)\n\na='boram'\n\n\na\n\n'boram'\n\n\n\na[0]\n\n'b'\n\n\n\na[0]='B'\n\nTypeError: 'str' object does not support item assignment\n\n\n- 리스트 원소 삭제\n(예제)\n아래와 같이 문자로 된 리스트를 선언하자.\n\na=['b','o','r','a','m']\na\n\n['b', 'o', 'r', 'a', 'm']\n\n\n사실 더 쉽게 선언할 수 있음\n\na='boram'   #string으로 a를 선언\n\n\ntype(a)\n\nstr\n\n\n\nlist(a)\n\n['b', 'o', 'r', 'a', 'm']\n\n\n\na=list(a)  #list(a)를 통하여 str을 list로 변환 \n\n\na  # 그 결과를 a에 다시 저장\n\n['b', 'o', 'r', 'a', 'm']\n\n\n첫 번째 원소를 삭제하고 싶다면?\n\n\ndel a[0]\na\n\n['o', 'r', 'a', 'm']\n\n\n- 리스트의 원소 추가\n(예제) 비어있는 리스틀를 만들고 원소 0,1,2 를 차례로 추가하여 보자.\n(풀이1)\n\na=[]\na\n\n[]\n\n\n\na= a+[0]\na\n\n[0]\n\n\n\na=a+[1]\na\n\n[0, 1]\n\n\n\na= a+[2]\na\n\n[0, 1, 2]\n\n\n(풀이2)\n\na=[]\na\n\n[]\n\n\n\na+=[0]\na\n\n[0]\n\n\n\na+=[1]\na\n\n[0, 1]\n\n\n\na+=[2]\na\n\n[0, 1, 2]\n\n\n\n암기법: 중복되는 변수를 지우고 연산자의 순서를 바꾼다.\n\n(풀이3) 리스트 특화기능(=메소드)를 이용\n\na=[]\na\n\n[]\n\n\n\na.append?\n\n\na.append(0)\na\n\n[0]\n\n\n\na.append(1)\na\n\n[0, 1]\n\n\n\na.append(2)\na\n\n[0, 1, 2]\n\n\n- a+[4]와 a.append(4)의 차이점은?\n(관찰1)\n\na=[1,2,3]\na+[4]  ## 리스트 a와 리스트 [4]의 연산결과\n\n[1, 2, 3, 4]\n\n\n\na  # a는 그대로임. 변화없음\n\n[1, 2, 3]\n\n\n(관찰2)\n\na=[1,2,3]\na.append(4)\n\n\na    # a자체가 변화함\n\n[1, 2, 3, 4]\n\n\n비슷해보이지만 굉장히 미묘한 차이가 있음\na.append(4) : a에 4를 append하라 \\(\\to\\) a가 변함\na+[4] : a와 4를 연산하고 수행결과를 보여달라"
  },
  {
    "objectID": "posts/python/python 2_0314.html#메소드리스트자료형에-특화된-특수한-함수들",
    "href": "posts/python/python 2_0314.html#메소드리스트자료형에-특화된-특수한-함수들",
    "title": "파이썬 2주차 (0314)",
    "section": "메소드(리스트자료형에 특화된 특수한 함수들)",
    "text": "메소드(리스트자료형에 특화된 특수한 함수들)\n(append)\n\na=[1,2,3,4]\na.append?\n\n\na.append(5)\na\n\n[1, 2, 3, 4, 5]\n\n\n(clear)\n\na=[1,2,3,4]\na.clear?\n\n\na.clear()\n\n\na\n\n[]\n\n\n(copy)\n\na=[1,2,3,4]\na.copy?\n\n\nb=a.copy()\nb\n\n[1, 2, 3, 4]\n\n\n(count)\n\na=[1,1,2,3,3,4,4,4,]\na.count(1)\n\n2\n\n\n\na.count(2) #특정 원소가 몇개 포함되어있는지 숫자 세줌\n\n1\n\n\n(extend)\n\na=[1,2,3,4]\nb=[-1,-2,-3,-4]\n\n\na.extend(b)\na\n\n[1, 2, 3, 4, -1, -2, -3, -4]\n\n\n\na.append(b)   \na\n\n[1, 2, 3, 4, -1, -2, -3, -4, [-1, -2, -3, -4]]\n\n\n(index)\n\na=[11,22,'a',True,22]\na.index(True)\n\n3\n\n\n\na.index('a')\n\n2\n\n\n\na.index(22)\n\n1\n\n\n(insert)\n\na=[1,2,3]\n\n\na.insert(1,88)\na\n\n[1, 88, 2, 3]\n\n\n(pop)\n\na=['a',1,2,'d']\na.pop()   # index= -1이므로 마지막원소가 나타남\n\n'd'\n\n\n\na   # a는 마지막 원소가 사라진 상태\n\n['a', 1, 2]\n\n\n\na.pop(0)   # index=0 이므로 첫번째 원소가 나타남\n\n'a'\n\n\n\na    # a에서는 첫번쨰 원소가 사라진 상태\n\n[1, 2]\n\n\n(remove)\n\na=['a',2,3,'d']\na.remove('d')\n\n\na\n\n['a', 2, 3]\n\n\n\na.remove('a')\na\n\n[2, 3]\n\n\n(reverse)\n\na=[1,2,3,4]\na.reverse()\na\n\n[4, 3, 2, 1]\n\n\n(sort)\n\na=[1,3,2,4]\na.sort()\na\n\n[1, 2, 3, 4]\n\n\n(다른예제들)\n\na=list('boram')\na\n\n['b', 'o', 'r', 'a', 'm']\n\n\n\na.sort()\na\n\n['a', 'b', 'm', 'o', 'r']\n\n\n\na.sort(reverse=True)\na\n\n['r', 'o', 'm', 'b', 'a']"
  },
  {
    "objectID": "posts/python/python 2_0314.html#중첩리스트",
    "href": "posts/python/python 2_0314.html#중첩리스트",
    "title": "파이썬 2주차 (0314)",
    "section": "중첩리스트",
    "text": "중첩리스트\n\nA=[[1,2,3],[4,5,6],[7,8,9]]\nA\n\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n- A는 아래와 같은 매트릭스로 이해할 수 있다.\n$\n\\[\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\\]\n$\n- A에서 (2,1)의 원소를 뽑고 싶다. = 1을 뽑고싶다.\n\nA[1,0]\n\nTypeError: list indices must be integers or slices, not tuple\n\n\n\n실패\n\n\nA[1][0]\n\n4\n\n\n\n성공\n\n성고의 이유를 분석해 보자.\n\nA[0]\n\n[1, 2, 3]\n\n\n\nA[0][0]\n\n1\n\n\n- 매트릭스는 아니지만 매트릭스 같음! - 1차원 배열을 다차원 배열로 확장할 수 있는 기본 아이디어를 제공함"
  },
  {
    "objectID": "posts/python/python 2_0314.html#리스트컴프리헨션",
    "href": "posts/python/python 2_0314.html#리스트컴프리헨션",
    "title": "파이썬 2주차 (0314)",
    "section": "리스트컴프리헨션 (★★★)",
    "text": "리스트컴프리헨션 (★★★)\n- 리스트 컴프리헨션을 이해하기 전에 for문에 대하여 알아보자.\n[예비학습] for문 벼락치기\n프로그램안에서 반복해서 무언가를 하고싶다 \\(\\to\\) for\n\nfor i in [0,1,2,3]:   # 반복실행계획\n    print(i)          # 반복실행내용, 탭을 이용하여 들여쓰기 해야한다. \n\n0\n1\n2\n3\n\n\n(예제) 1,2,3,4의 합을 for문을 이용하여 구해보자.\n\n_sum = 0\nfor i in [1,2,3,4]:\n    _sum = _sum + i\n\n\n_sum\n\n10\n\n\n- 예제: $ 2^0, 2^1, 2^2, 2^3$ 를 원소로 가지는 리스트를 생성\n(풀이1)\n\nx=[2**0, 2**1, 2**2, 2**3]    ## 2의 0승\nx\n\n[1, 2, 4, 8]\n\n\n(풀이2) for문을 이용\n\nx=[]\nfor i in [0,1,2,3]:\n    x.append(2**i)  \n\n\nx\n\n[1, 2, 4, 8]\n\n\n(풀이3) for문을 이용\n\nx=[]\nfor i in [0,1,2,3]:\n    x= x+[2**i]\nx\n\n[1, 2, 4, 8]\n\n\n(풀이4) for문을 이용\n\nx=[]\nfor i in [0,1,2,3]:\n    x+= [2**i]\nx(풀이2) for문을 이용\n\n[1, 2, 4, 8]\n\n\n(풀이5) 리스트컴프리헨션을 이용한 풀이\n\nx= [2**i for i in [0,1,2,3]]\nx\n\n[1, 2, 4, 8]\n\n\n- 리스트컴프리헨션의 문법 암기방법 - 집합에서 조건제시법을 연상 - 원소나열법, 조건제시법 - \\(\\{2^0, 2^1, 2^2, 2^3\\} = \\{2^i: \\text{for} i \\in \\{0,1,2,3\\}\\)\n- 리스트컴프리헨션이란? - 리스트를 매우 효율적으로 만드는 테크닉 - for문에 비하여 가지고 있는 장점 : 1. 코드가 간결하다. 2, 빠르다\n- 예제: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들자.\n\n['SSSS','PPPP','AAAA','MMMM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n(풀이)\n\n[i*4 for i in 'SPAM']\n\n['SSSS', 'PPPP', 'AAAA', 'MMMM']\n\n\n- 예제: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들자.\n- 예제: 리스트 컴프리헨션을 이용하여 아래와 같은 리스트를 만들자.\n\n['X1','X2','X3','Y1','Y2','Y3']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n(풀이)\n\nfor i in 'XY':\n    for j in '123':\n        print(i+j)\n\nX1\nX2\nX3\nY1\nY2\nY3\n\n\n\n[i+j for i in 'XY' for j in '123']\n\n['X1', 'X2', 'X3', 'Y1', 'Y2', 'Y3']\n\n\n- 예제: 리스트 컴프리헨션을 이용하여 통계1,,..,통계5,수학1,…,수학5를 만들어라\n(풀이)\n\n[i+j for i in ['stat', 'math'] for j in '12345']\n\n['stat1',\n 'stat2',\n 'stat3',\n 'stat4',\n 'stat5',\n 'math1',\n 'math2',\n 'math3',\n 'math4',\n 'math5']\n\n\n(다른풀이) 참고로 for문을 쓰면 좀 복잡해진다.\n\n_lst=[]\nfor x in ['stat', 'math']:\n    for y in '12345':\n        _lst = _lst + [x+y]\n\n\n_lst\n\n['stat1',\n 'stat2',\n 'stat3',\n 'stat4',\n 'stat5',\n 'math1',\n 'math2',\n 'math3',\n 'math4',\n 'math5']\n\n\n- 예제: ’jbnu’를 이용하여 아래와 같은 리스트르 만들어라.\n\n['j','b','n','u']\n\n['j', 'b', 'n', 'u']\n\n\n\nlist('jbnu')\n\n['j', 'b', 'n', 'u']\n\n\n(풀이)\n\n[x for x in 'jbnu']\n\n['j', 'b', 'n', 'u']\n\n\n-예제: x에는 무엇이 있을까?\n(경우1)\n\nx=1\nlst=[]\nfor x in 'jbnu':\n    lst = lst + [x]\n\n\nlst\n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n'u'\n\n\n(경우2)\n\nx=1\nlst = [x for x in 'jbnu']\nlst\n\n['j', 'b', 'n', 'u']\n\n\n\nx\n\n1\n\n\n- 예제: [X1,X2,X3,…,X100]과 같은 리스트를 만들어보자.\n(풀이)\n\n['X'+str(i) for i in [1,2,3,4]]\n\n['X1', 'X2', 'X3', 'X4']\n\n\n\n['X'+str(i) for i in [1:100]]   #오류!!\n\nSyntaxError: invalid syntax (1716365648.py, line 1)\n\n\n[예비학습]\n\nrange(0,10)\n\nrange(0, 10)\n\n\n\n_tmp = range(0,10)\n\n\ntype(_tmp)\n\nrange\n\n\n\nlist(_tmp)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(0,10)) #0을 포함, 10을 미포함\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n이게 중요한 것. range(0,10)을 리스트화시키면 [0,1,2,…,9]와 같은기능을 얻을 수 있다.\n\n\nlist(range(10))  # 0은 생략가능\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(2,10))  # 2는 포함, 10은 미포함\n\n[2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nlist(range(1,10,2))  # 2칸씩! \n\n[1, 3, 5, 7, 9]\n\n\n예비학습 끝\n\n['X'+str(i) for i in list(range(1,101))]  # 세로로 넘 길엉 \n\n['X1',\n 'X2',\n 'X3',\n 'X4',\n 'X5',\n 'X6',\n 'X7',\n 'X8',\n 'X9',\n 'X10',\n 'X11',\n 'X12',\n 'X13',\n 'X14',\n 'X15',\n 'X16',\n 'X17',\n 'X18',\n 'X19',\n 'X20',\n 'X21',\n 'X22',\n 'X23',\n 'X24',\n 'X25',\n 'X26',\n 'X27',\n 'X28',\n 'X29',\n 'X30',\n 'X31',\n 'X32',\n 'X33',\n 'X34',\n 'X35',\n 'X36',\n 'X37',\n 'X38',\n 'X39',\n 'X40',\n 'X41',\n 'X42',\n 'X43',\n 'X44',\n 'X45',\n 'X46',\n 'X47',\n 'X48',\n 'X49',\n 'X50',\n 'X51',\n 'X52',\n 'X53',\n 'X54',\n 'X55',\n 'X56',\n 'X57',\n 'X58',\n 'X59',\n 'X60',\n 'X61',\n 'X62',\n 'X63',\n 'X64',\n 'X65',\n 'X66',\n 'X67',\n 'X68',\n 'X69',\n 'X70',\n 'X71',\n 'X72',\n 'X73',\n 'X74',\n 'X75',\n 'X76',\n 'X77',\n 'X78',\n 'X79',\n 'X80',\n 'X81',\n 'X82',\n 'X83',\n 'X84',\n 'X85',\n 'X86',\n 'X87',\n 'X88',\n 'X89',\n 'X90',\n 'X91',\n 'X92',\n 'X93',\n 'X94',\n 'X95',\n 'X96',\n 'X97',\n 'X98',\n 'X99',\n 'X100']\n\n\n(아래와 같은 풀이도 가능)\n\n['X'+str(i) for i in range(1,13)]  # 리스트화해주지 않아도 가능 for i in 뒤에 list뿐 아니라.. str도 되고... \n\n['X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', 'X8', 'X9', 'X10', 'X11', 'X12']\n\n\n(딴생각) for문 뒤에 올 수 있는 것이 무엇인지 생각해보자.\n\nfor i in '1234':\n    print(i)\n\n1\n2\n3\n4\n\n\n\nfor i in [1,2,3,4]:\n    print(i)\n\n1\n2\n3\n4\n\n\n\nfor i in (1,2,3,4):   # 튜플\n    print(i)\n\n1\n2\n3\n4\n\n\n\nfor i in {1,2,3,4}: # set\n    print(i)\n\n1\n2\n3\n4\n\n\n\nfor i in {'name':'iu','age':31}:   # 딕셔너리\n    print(i)\n\nname\nage\n\n\n\nfor i in range(1,5):\n    print(i)\n\n1\n2\n3\n4\n\n\n(숙제)\n리스트컴프리헨션을 이용하여 아래와 같은 리스트를 만들어라\n[‘X1’,‘X2X2’,‘X3X3X3’,‘X4X4X4X4’,‘X5X5X5X5X5’]\n\n[('X'+str(i))*i for i in range(1,6)]\n\n['X1', 'X2X2', 'X3X3X3', 'X4X4X4X4', 'X5X5X5X5X5']"
  },
  {
    "objectID": "posts/python/python 5_0404.html",
    "href": "posts/python/python 5_0404.html",
    "title": "파이썬 5주차 (0404)",
    "section": "",
    "text": "소스코드 관리(모듈, 패키지, 라이브러리)\nintro\n- 현재 파이썬은 길이가 2인 벡터의 덧셈을 지원하지 않음\n\na=[1,2]\nb=[3,4]\na+b\n\n[1, 2, 3, 4]\n\n\n- 아래와 같은 기능을 구현하는 함수를 만들고 싶음\n[1,2],[3,4] -> [4,6]\n- 구현\n\ndef vec2_add(a,b):\n    return [a[0]+b[0], a[1]+b[1]]\n\n- test\n\na=[1,2]\nb=[3,4]\n\n\nvec2_add(a,b)\n\n[4, 6]\n\n\nmake myfuns.py\n- 생각해보니까 vec2_add는 내가 앞으로 자주 쓸 기능임\n- 그런데 현재 사용방법으로는 내가 노트북파일을 새로 만들때마다 def vec2_add(a,b):와 같은 함수를 매번 정의해줘야 하는 불편함이 있다.\n해결1\n- 자주 사용하는 함수를 myfuns.py에 저장한다. (4주차 수업)\n# myfuns.py\ndef vec2_add(a,b):\n    return [a[0]+b[0], a[1]+b[1]]\n%run myfuns를 실행\n준비:“00” -> 커널재시작\n\n# \n\n\n%run myfuns\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n해결 2\n- 자주 사용하는 함수를 myfuns.py에 저장한다. (4주차 수업)\n# myfuns.py\ndef vec2_add(a,b):\n    return [a[0]+b[0], a[1]+b[1]]\n- import myfuns를 이용\n(준비) “00” -> 커널 재시작\n\nimport myfuns\n\n\na=[1,2]\nb=[3,4]\nmyfuns.vec2_add(a,b)\n\n[4, 6]\n\n\n\nimport 기본\n-사용방법1\n준비: “00” -> 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nmyfuns.vec2_add의 의미: myfuns.py라는 파일안에 vec2_add라는 함수가 있음. 그것을 실행하라.\n.의 의미: 상위, 하위의 개념!\n\n(주의) 아래와 같이 사용 불가능 하다.\n\nvec2_add([1,2],[3,4])  #myfuns가 import가 된거지 vec2Add가 import가 된 것이 아님.\n\nNameError: name 'vec2_add' is not defined\n\n\n- 사용방법2\n준비: “00” -> 커널재시작\n\nfrom myfuns import vec2_add\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nmyfuns.vec2_add([1,2],[3,4])  # myfuns안의 vec2_add만 임포트했지 myfuns자체를 임포트 한것은 아님..\n\nNameError: name 'myfuns' is not defined\n\n\n- 사용방법3\n준비: “00” -> 커널재시작\n\nimport myfuns\nfrom myfuns import vec2_add\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_sub([1,2],[3,4])   # vec2_sub는 import하지 않았기 때문에 오류남.. \n\nNameError: name 'vec2_sub' is not defined\n\n\n\nmyfuns.vec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n- 사용방법4\n준비: “00” -> 커널재시작\n\nfrom myfuns import vec2_add, vec2_sub\n\n\nvec2_add([1,2],[3,4]), vec2_sub([1,2],[3,4])\n\n([4, 6], [-2, -2])\n\n\n- 사용방법5\n준비: “00” -> 커널재시작\n\nfrom myfuns import *   # *는 all의 의미\n\n\nvec2_add([1,2],[3,4]), vec2_sub([1,2],[3,4])\n\n([4, 6], [-2, -2])\n\n\n- 사용방법6\n준비: “00” -> 커널재시작\n\nimport myfuns as mf \n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nmf.vec2_sub([1,2],[3,4])\n\n[-2, -2]\n\n\n(오히려 아래는 실행불가능)\n\nmyfuns.vec2_add([1,2],[3,4])\n\nNameError: name 'myfuns' is not defined\n\n\n- 잘못된 사용방법1\n준비: “00” -> 커널재시작\n\nimport myfuns as mf\nfrom mf import vec2_add\n\nModuleNotFoundError: No module named 'mf'\n\n\n- 사용방법 7\n준비: “00” -> 커널재시작\n\nimport myfuns as mf\nfrom myfuns import vec2_add as add\n\n\nmf.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n\nvec2_add([1,2],[3,4])   # 위에서 vec2_add를 add로 부르기로 했음. 그래서 이건 안뎀 \n\nNameError: name 'vec2_add' is not defined\n\n\n\nadd([1,2],[3,4])\n\n[4, 6]\n\n\n\n\n도움말 작성기능\n- mf란 무엇인가?\n준비: “00” -> 커널재시작\n\nimport myfuns as mf\n\n\nmf\n\n<module 'myfuns' from 'C:\\\\Users\\\\koinu\\\\python2022\\\\myfuns.py'>\n\n\n\nmf?\n\n\nType:        module\nString form: <module 'myfuns' from 'C:\\\\Users\\\\koinu\\\\python2022\\\\myfuns.py'>\nFile:        c:\\users\\koinu\\python2022\\myfuns.py\nDocstring:   <no docstring>\n\n\n\n\ntype(mf)\n\nmodule\n\n\n\nmf의 타입은 모듈이라고 나옴, 현재 단계에서는 무엇인지 알기 어려움..\n\n- Docstring의 내용을 채울 수 있을까?\n준비1: myfuns.py의 파일을 수정한다. (큰따옴표 ““” 세개)\n준비2: “00”->커널재시작\n\nimport myfuns as mf\n\n\nmf?\n\n\nType:        module\nString form: <module 'myfuns' from 'C:\\\\Users\\\\koinu\\\\python2022\\\\myfuns.py'>\nFile:        c:\\users\\koinu\\python2022\\myfuns.py\nDocstring:   이것은 길이가 2인 벡터이 합 혹은 차를 구하는 모듈입니다.\n\n\n\n\n\n주의점\n- myfuns.py는 최초 한번만 import된다.\n준비: “00” -> 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\nmyfuns.py파일을 열고 함수를 바꾸자.\n\"\"\"이것은 길이가 2인 벡터이 합 혹은 차를 구하는 모듈입니다.\"\"\"\n\ndef vec2_add(a,b):\n    print(\"이것은 myfuns.py에 정의된 함수입니다.\")\n    return [a[0]+b[0], a[1]+b[1]]\n\n\ndef vec2_sub(a,b):\n    return [a[0]-b[0], a[1]-b[1]]\n다시 myfuns를 로드하고 위를 실행하여 보자\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n[4, 6]\n\n\n바뀐내용이 적용되지 않는다.\n커널을 다시 시작하고 임포트해보자.\n“00” -> 커널재시작\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[3,4])\n\n이것은 myfuns.py에 정의된 함수입니다.\n\n\n[4, 6]\n\n\n- myfuns.py는 주피너노트북파일과 같은 폴더내에 존재해야 한다.\n준비1: “00”->커널재시작\n준비2: myfuns.py 을 복사하여 다른 폴더로 이동. 예를들면 IP0403폴더를 만들고 그 폴더안에 myfuns2.py파일을 만들자.\n\nimport myfuns  # 주피터노트북과 같은 폴더에 있는 myfuns는 잘 로드되지만\n\n\nimport myfuns2 # 주피터노트북과 다른 폴더에 있는 myfuns2는 그렇지 않다.\n\nModuleNotFoundError: No module named 'myfuns2'\n\n\n- IP0403 폴더에 있는 myfuns2.py를 실행하기 위해서는 아래와 같이 할 수 있다.\n준비: “00” -> 커널재시작\n\nfrom IP0403 import myfuns2\n\n\nmyfuns2.vec2_add([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다.\n\n\n[4, 6]\n\n\n- 아래도 가능하다.\n준비: “00” -> 커널재시작\n\nfrom IP0403.myfuns2 import vec2_add as add\n\n\nadd([1,2],[3,4])\n\n이것은 myfuns2.py에 정의된 함수입니다.\n\n\n[4, 6]\n\n\n참고로 아래는 모두 정의되지 않음\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])\n\nNameError: name 'IP0403' is not defined\n\n\n\nmyfuns2.vec2_add([1,2],[3,4])\n\nNameError: name 'myfuns2' is not defined\n\n\n\nvec2_add([1,2],[3,4])\n\nNameError: name 'vec2_add' is not defined\n\n\n\n\nimport 고급\n\n폴더와 함께 사용할시\n- 언뜻 생각하면 아래가 가능할 것 같다.\nimport IP0403\nIP0403.myfuns.vec2_add([1,2],[3,4])\n- 하지만 불가능\n준비: “00” -> 커널재시작\n\nimport IP0403\n\n여기까지는 됨..\n\nIP0403.myfuns2.add([1,2],[3,4])\n\nAttributeError: module 'IP0403' has no attribute 'myfuns2'\n\n\n\n여기서 불가능하다.\n\n- (암기) IP0403 폴더안에 __init__.py라는 파일을 만들고 내용에 아래와 같이 쓰면 가능하다.\n# ./IP0403/__init__.py\nform. import myfuns2\n준비1: 위의 지침을 따른다.\n준비2: “00” -> 커널재시작\n\nimport IP0403\n\n\nIP0403.myfuns2.vec2_add([1,2],[3,4])  \n\n이것은 myfuns2.py에 정의된 함수입니다.\n\n\n[4, 6]\n\n\n컴퓨터 상식\n\n. : 현재폴더를 의미\n.. : 상위폴더를 의미\n./myfuns.py : 현재폴더안에 있는 myfuns.py를 의미\n./IP0403/myfuns2.py : 현재폴더안에 IP0403폴더안의 myfuns2.py를 의미\n../myfuns.py : 현재폴더보다 한단계 상위폴더에 있는 myfuns.py를 의미\ncd ./IP0403 : 현재 폴더안에 있는 IP0403폴더로 이동해라. (cd IP0403으로 줄여쓸 수 있음)\ncd .. 현재 폴더보다 한단계 상위폴더로 이동해라.\n\n따라서 from . import myfuns2는 현재 폴더에서 myfuns2를 찾아서 임포트 하라는 의미로 해석가능\n- 의미상으로 보면 아래가 실해아능할 것 같은데 불가능하다.\n\n# import myfuns.py\nfrom . import myfuns\n\nImportError: attempted relative import with no known parent package\n\n\n\n\n\nslite-packages (실습금지)\nhttps://guebin.github.io/IP2022/2022/04/03/(5%EC%A3%BC%EC%B0%A8)-4%EC%9B%942%EC%9D%BC.html#site-packages-(%EC%8B%A4%EC%8A%B5%EA%B8%88%EC%A7%80)\n\n\n모듈, 패키지, 라이브러리?\n- 모듈의 개념은 아까 살펴본 것과 같다. (import를 하여 생기게 되는 오브젝트)\n- 교수님들: 모듈이 모이면 패키지라고 부른다. 그리고 라이브러리는 패키지보다 큰 개념이다.\n-그런데 구분이 모호하다.\n\nimport numpy as np   # 오잉 왜 안되지... \n\nModuleNotFoundError: No module named 'numpy'\n\n\n\ntype(np)\n\nNameError: name 'np' is not defined\n\n\n- python 에서 numpy의 type은 모듈\n- 그런데 numpy package라고 검색하면 검색이 된다.\n- 심지어 numpy library 라고 해도 검색가능\n- 교수님 생각: 넘파이모듈, 넘파이패키지, 넘파이라이브러리 다 맞는 말임\n(숙제)\n\nimport myfuns\n\n\nmyfuns.vec2_add([1,2],[5,6])\n\n이것은 myfuns.py에 정의된 함수입니다.\n\n\n[6, 8]\n\n\n\nmyfuns?\n\n\nType:        module\nString form: <module 'myfuns' from 'C:\\\\Users\\\\koinu\\\\python2022\\\\myfuns.py'>\nFile:        c:\\users\\koinu\\python2022\\myfuns.py\nDocstring:   이것은 길이가 2인 벡터이 합 혹은 차를 구하는 모듈입니다. 202250926"
  },
  {
    "objectID": "posts/python/python 6_0411.html",
    "href": "posts/python/python 6_0411.html",
    "title": "파이썬 6주차 (0411)",
    "section": "",
    "text": "imports\n\nimport numpy as np\n\n\n\nnumpy공부 3단계: 차원\n\n2차원 배열과 연립 1차 방정식\n- 아래의 연립방정식 고려\n\\(\\begin{cases} y+z+w = 3 \\\\ x+z+w = 3 \\\\ x+y+w = 3 \\\\ x+y+z = 3 \\end{cases}\\)\n- 행렬표현?\n\\(\\begin{bmatrix} 0 & 1 & 1 & 1 \\\\ 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 \\\\ 1 & 1 & 1 & 0 \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} 3 \\\\ 3 \\\\ 3 \\\\ 3 \\end{bmatrix}\\)\n- 풀이\n\nA = np.array([[0,1,1,1],[1,0,1,1],[1,1,0,1],[1,1,1,0]])\nA\n\narray([[0, 1, 1, 1],\n       [1, 0, 1, 1],\n       [1, 1, 0, 1],\n       [1, 1, 1, 0]])\n\n\n\nb= np.array([3,3,3,3]).reshape(4,1)\nb\n\narray([[3],\n       [3],\n       [3],\n       [3]])\n\n\n\nnp.linalg.inv(A) @ b \n\narray([[1.],\n       [1.],\n       [1.],\n       [1.]])\n\n\n- 다른풀이\nb를 아래와 같이 만들어도 된다.\n\nb=np.array([3,3,3,3])\nb\n\narray([3, 3, 3, 3])\n\n\n\nb.shape # b.shape은 길이가 1인 튜플로 나온다. \n\n(4,)\n\n\n\nnp.linalg.inv(A) @ b \n\narray([1., 1., 1., 1.])\n\n\n\n\n@의 유연성\n- 엄밀하게는 아래의 행렬곱이 가능하다. - (2,2) @ (2,1) => (2,1) - (1,2) @ (2,2) => (1,2)\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nA@b\n\narray([[ 5],\n       [11]])\n\n\n\nA.shape, b.shape, (A@b).shape\n\n((2, 2), (2, 1), (2, 1))\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nb@A \n\narray([[ 7, 10]])\n\n\n\nA.shape, b.shape, (b@A).shape\n\n((2, 2), (1, 2), (1, 2))\n\n\n- 당연히 아래는 성립안한다.\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(2,1) \nb@A\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 2 is different from 1)\n\n\n\nA = np.array([1,2,3,4]).reshape(2,2) \nb = np.array([1,2]).reshape(1,2) \nA@b\n\nValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)->(n?,m?) (size 1 is different from 2)\n\n\n- 아래는 어떨까? 계산가능할까? \\(\\to\\) 모두 계산가능! - (2,) @ (2,2) = (2,) - (2,2) @ (2,) = (2,)\n\nA = np.array([1,2,3,4]).reshape(2,2)\nb = np.array([1,2]) \nA@b\n\narray([ 5, 11])\n\n\n\nA.shape, b.shape, (A@b).shape \n\n((2, 2), (2,), (2,))\n\n\n\nb를 마치 (2,1)처럼 해석하여 행렬곱하고 결과는 다시 (2,) 로 만든것 같다.\n\n\nb@A\n\narray([ 7, 10])\n\n\n\nA.shape, b.shape, (b@A).shape \n\n((2, 2), (2,), (2,))\n\n\n\n이때는 \\(b\\)를 마치 (1,2)처럼 해석하여 행렬곱하고 결과는 다시 (2,)로 만든것 같다.\n\n- 아래는 어떠할까?\n\nb1 = np.array([1,2,3,4]) \nb2 = np.array([1,2,3,4]) \nb1@b2 \n\n30\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((4,), (4,), ())\n\n\n\n(1,4) @ (4,1) = (1,1) 로 생각\n\n- 즉 위는 아래와 같이 해석하고 행렬곱한것과 결과가 같다.\n\nb1 = np.array([1,2,3,4]).reshape(1,4) \nb2 = np.array([1,2,3,4]).reshape(4,1) \nb1@b2 \n\narray([[30]])\n\n\n\nb1.shape, b2.shape, (b1@b2).shape \n\n((1, 4), (4, 1), (1, 1))\n\n\n- 때로는 (4,1) @ (1,4)와 같은 계산결과를 얻고 싶을 수 있는데 이때는 차원을 명시해야함\n\nb1 = np.array([1,2,3,4]).reshape(4,1) \nb2 = np.array([1,2,3,4]).reshape(1,4) \nb1@b2 \n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\n\n\n\n차원\n- 넘파이배열의 차원은 .shape 으로 확인가능\n- 아래는 모두 미묘하게 다르다.\n\na=np.array(3.14) # 스칼라, 0d array \na, a.shape\n\n(array(3.14), ())\n\n\n\na=np.array([3.14]) # 벡터, 1d array \na, a.shape\n\n(array([3.14]), (1,))\n\n\n\na=np.array([[3.14]]) # 매트릭스, 2d array \na, a.shape\n\n(array([[3.14]]), (1, 1))\n\n\n\na=np.array([[[3.14]]]) # 텐서, 3d array \na, a.shape\n\n(array([[[3.14]]]), (1, 1, 1))\n\n\n\n\n\nnumpy공부 4단계: 축\n\nnp.concatenate\n- 기본예제\n\na=np.array([1,2]) \nb=-a\n\n\nnp.concatenate([a,b]) \n\narray([ 1,  2, -1, -2])\n\n\n- 응용\n\na=np.array([1,2])\nb=-a \nc=np.array([3,4,5])\n\n\nnp.concatenate([a,b,c])\n\narray([ 1,  2, -1, -2,  3,  4,  5])\n\n\n\n여기까진 딱히 칸캐터네이트의 메리트가 없어보임\n리스트였다면 a+b+c 하면 되는 기능이니까?\n\n- 2d array에 적용해보자.\n\na=np.arange(4).reshape(2,2) \nb=-a\n\n\nnp.concatenate([a,b]) \n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 0, -1],\n       [-2, -3]])\n\n\n- 옆으로 붙일려면?\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 0,  1,  0, -1],\n       [ 2,  3, -2, -3]])\n\n\n- 위의 코드에서 axis=1 이 뭐지? axis=0,2 등을 치면 결과가 어떻게 될까?\n\nnp.concatenate([a,b],axis=0)\n\narray([[ 0,  1],\n       [ 2,  3],\n       [ 0, -1],\n       [-2, -3]])\n\n\n\n이건 그냥 np.concatenate([a,b])와 같다.\nnp.concatenate([a,b])는 np.concatenate([a,b],axis=0)의 생략버전이군?\n\n\nnp.concatenate([a,b],axis=2)\n\nAxisError: axis 2 is out of bounds for array of dimension 2\n\n\n\n이런건 없다.\n\n- axis의 의미가 뭔지 궁금함. 좀 더 예제를 살펴보자.\n\na=np.array(range(2*3*4)).reshape(2,3,4)\na\n\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n\n\nb=-a\nb\n\narray([[[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=0) \n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=1) \n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11],\n        [  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23],\n        [-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\nnp.concatenate([a,b],axis=2) \n\narray([[[  0,   1,   2,   3,   0,  -1,  -2,  -3],\n        [  4,   5,   6,   7,  -4,  -5,  -6,  -7],\n        [  8,   9,  10,  11,  -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15, -12, -13, -14, -15],\n        [ 16,  17,  18,  19, -16, -17, -18, -19],\n        [ 20,  21,  22,  23, -20, -21, -22, -23]]])\n\n\n\n이번에는 axis=2까지 된다?\n\n\nnp.concatenate([a,b],axis=3) \n\nAxisError: axis 3 is out of bounds for array of dimension 3\n\n\n\naxis=3까지는 안된다?\n\n- 뭔가 나름의 방식으로 합쳐지는데 원리가 뭘까?\n(분석1) np.concatenate([a,b],axis=0)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=0).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\n첫번째차원이 바뀌었다 => 첫번째 축이 바뀌었다 => axis=0 (파이썬은 0부터 시작하니까!)\n\n(분석2) np.concatenate([a,b],axis=1)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\n두번째차원이 바뀌었다 => 두번째 축이 바뀌었다 => axis=1\n\n(분석3) np.concatenate([a,b],axis=2)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n\n세번째차원이 바뀌었다 => 세번째 축이 바뀌었다 => axis=2\n\n(분석4) np.concatenate([a,b],axis=3)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\na.shape, b.shape, np.concatenate([a,b],axis=3).shape\n\nAxisError: axis 3 is out of bounds for array of dimension 3\n\n\n\n네번째차원이 없다 => 네번째 축이 없다 => axis=3으로 하면 에러가 난다.\n\n(보너스1)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-1)\n\narray([[[  0,   1,   2,   3,   0,  -1,  -2,  -3],\n        [  4,   5,   6,   7,  -4,  -5,  -6,  -7],\n        [  8,   9,  10,  11,  -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15, -12, -13, -14, -15],\n        [ 16,  17,  18,  19, -16, -17, -18, -19],\n        [ 20,  21,  22,  23, -20, -21, -22, -23]]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=-1).shape\n\n((2, 3, 4), (2, 3, 4), (2, 3, 8))\n\n\n\n마지막 차원이 바뀌었다 => 마지막 축이 바뀌었다 => axis = -1\n\n(보너스2)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-2)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11],\n        [  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23],\n        [-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=-2).shape\n\n((2, 3, 4), (2, 3, 4), (2, 6, 4))\n\n\n\n마지막에서 2번째 차원이 바뀌었다 => 마지막에서 2번째 축이 바뀌었다 => axis = -2\n\n(보너스3)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-3)\n\narray([[[  0,   1,   2,   3],\n        [  4,   5,   6,   7],\n        [  8,   9,  10,  11]],\n\n       [[ 12,  13,  14,  15],\n        [ 16,  17,  18,  19],\n        [ 20,  21,  22,  23]],\n\n       [[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]],\n\n       [[-12, -13, -14, -15],\n        [-16, -17, -18, -19],\n        [-20, -21, -22, -23]]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=-3).shape\n\n((2, 3, 4), (2, 3, 4), (4, 3, 4))\n\n\n\n마지막에서 3번째 차원이 바뀌었다 => 마지막에서 3번째 축이 바뀌었다 => axis = -3\n\n(보너스3)\n\na=np.array(range(2*3*4)).reshape(2,3,4) \nb=-a \n\n\nnp.concatenate([a,b],axis=-4)\n\nAxisError: axis -4 is out of bounds for array of dimension 3\n\n\n\n마지막에서 4번째 차원은 없다 => 마지막에서 4번째 축이 없다 => axis = -4는 에러가 난다.\n\n- 0차원은 축이 없으므로 concatenate를 쓸 수 없다.\n\na= np.array(1)\nb= np.array(-1) \n\n\na.shape, b.shape\n\n((), ())\n\n\n\nnp.concatenate([a,b])\n\nValueError: zero-dimensional arrays cannot be concatenated\n\n\n- 꼭 a,b가 같은 차원일 필요는 없다.\n\na=np.array(range(4)).reshape(2,2) \nb=np.array(range(2)).reshape(2,1)  \n\n\nnp.concatenate([a,b],axis=1)\n\narray([[0, 1, 0],\n       [2, 3, 1]])\n\n\n\na.shape, b.shape, np.concatenate([a,b],axis=1).shape\n\n((2, 2), (2, 1), (2, 3))\n\n\n\n\nnp.stack\n- 혹시 아래가 가능할까?\n\n(3,) 결합 (3,) => (3,2)\n\n\na=np.array([1,2,3])\nb=-a\n\n\na,b\n\n(array([1, 2, 3]), array([-1, -2, -3]))\n\n\n\nnp.concatenate([a,b],axis=1)\n\nAxisError: axis 1 is out of bounds for array of dimension 1\n\n\n\n불가능\n\n- 아래와 같이 하면 해결가능\n\na=np.array([1,2,3]).reshape(3,1) \nb=-a\n\n\na,b\n\n(array([[1],\n        [2],\n        [3]]),\n array([[-1],\n        [-2],\n        [-3]]))\n\n\n\nnp.concatenate([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n\n분석: (3) (3) => (3,1) (3,1) => (3,1) concat (3,1)\n\n- 위의 과정을 줄여서 아래와 같이 할 수 있다.\n\na=np.array([1,2,3])\nb=-a\n\n\nnp.stack([a,b],axis=1)\n\narray([[ 1, -1],\n       [ 2, -2],\n       [ 3, -3]])\n\n\n- 아래도 가능\n\nnp.stack([a,b],axis=0)\n\narray([[ 1,  2,  3],\n       [-1, -2, -3]])\n\n\n- 분석해보고 외우자\n(분석1)\n\na=np.array([1,2,3])\nb=-a\n\n\na.shape, b.shape, np.stack([a,b],axis=0).shape\n\n((3,), (3,), (2, 3))\n\n\n\n\n\n=> 첫 위치에 축을 추가 (axis=0) => (1,3) (1,3) => (2,3)\n\n\n\n(분석2)\n\na=np.array([1,2,3])\nb=-a\n\n\na.shape, b.shape, np.stack([a,b],axis=1).shape\n\n((3,), (3,), (3, 2))\n\n\n\n\n\n=> 두 위치에 축을 추가 (axis=1) => (3,1) (3,1) => (3,2)\n\n\n\n- 고차원예제\n\na=np.arange(3*4*5).reshape(3,4,5) \nb=-a\n\n\na.shape, b.shape\n\n((3, 4, 5), (3, 4, 5))\n\n\n\nnp.stack([a,b],axis=0).shape # (3,4,5) => (1,3,4,5) // 첫 위치에 축이 추가되고 스택 \n\n(2, 3, 4, 5)\n\n\n\nnp.stack([a,b],axis=1).shape # (3,4,5) => (3,1,4,5) // 두번째 위치에 축이 추가되고 스택 \n\n(3, 2, 4, 5)\n\n\n\nnp.stack([a,b],axis=2).shape # (3,4,5) => (3,4,1,5) // 세번째 위치에 축이 추가되고 스택 \n\n(3, 4, 2, 5)\n\n\n\nnp.stack([a,b],axis=3).shape # (3,4,5) => (3,4,5,1) // 네번째 위치에 축이 추가되고 스택 \n\n(3, 4, 5, 2)\n\n\n\nnp.stack([a,b],axis=-1).shape # axis=-1 <=> axis=3 \n\n(3, 4, 5, 2)\n\n\n\nnp.stack([a,b],axis=-2).shape # axis=-2 <=> axis=2\n\n(3, 4, 2, 5)\n\n\nnp.concatenate 는 축의 총 갯수를 유지하면서 결합, np.stack은 축의 갯수를 하나 증가시키면서 결합\n\n\nsum\n- 1차원\n\na = np.array([1,2,3]) \na\n\narray([1, 2, 3])\n\n\n\na.sum()\n\n6\n\n\n\na.sum(axis=0)\n\n6\n\n\n- 2차원\n\na=np.array(range(6)).reshape(2,3)\na\n\narray([[0, 1, 2],\n       [3, 4, 5]])\n\n\n\na.sum() # 전체합\n\n15\n\n\n\na.sum(axis=0) \n\narray([3, 5, 7])\n\n\n\na.sum(axis=1) \n\narray([ 3, 12])\n\n\n- 2차원 결과 분석\n\na.shape, a.sum(axis=0).shape\n\n((2, 3), (3,))\n\n\n\n첫번째 축이 삭제됨 => axis=0\n\n\na.shape, a.sum(axis=1).shape\n\n((2, 3), (2,))\n\n\n\n두번째 축이 삭제됨 => axis=1\n\n- 연습\n\na=np.array(range(10)).reshape(5,2) \na\n\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n\n\n(문제1) 1열의 합, 2열의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) => (2,) 로 나와야 한다. (그럼 첫번째 축이 삭제되어야 하네?)\n\na.sum(axis=0)\n\narray([20, 25])\n\n\n(문제2) 1행의 합, 2행의 합, … , 5행의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) => (5,)로 나와야 한다. (그럼 두번째 축이 삭제되어야 하네?)\n\na.sum(axis=1)\n\narray([ 1,  5,  9, 13, 17])\n\n\n(문제3) a의 모든원소의 합을 계산하고 싶다면?\n(풀이) 차원이 (5,2) => () 로 나와야 한다. (첫번째축, 두번째축이 모두 삭제되어야 하네?)\n\na.sum(axis=(0,1))\n\n45\n\n\n\na.sum() # 즉 a.sum(axis=(0,1))이 디폴트값임 \n\n45\n\n\n\n\nmean, std, max, min, prod\n- 모두 sum이랑 유사한 논리\n\na=np.array(range(10)).reshape(5,2)\na\n\narray([[0, 1],\n       [2, 3],\n       [4, 5],\n       [6, 7],\n       [8, 9]])\n\n\n\na.mean(axis=0), a.std(axis=0), a.max(axis=0), a.min(axis=0), a.prod(axis=0)\n\n(array([4., 5.]),\n array([2.82842712, 2.82842712]),\n array([8, 9]),\n array([0, 1]),\n array([  0, 945]))\n\n\n\na.mean(axis=1), a.std(axis=1), a.max(axis=1), a.min(axis=1), a.prod(axis=1)\n\n(array([0.5, 2.5, 4.5, 6.5, 8.5]),\n array([0.5, 0.5, 0.5, 0.5, 0.5]),\n array([1, 3, 5, 7, 9]),\n array([0, 2, 4, 6, 8]),\n array([ 0,  6, 20, 42, 72]))\n\n\n- 참고로 std는 분포를 n으로 나눈다.\n\na=np.array([1,2,3,4])\na.std()\n\n1.118033988749895\n\n\n\nnp.sqrt(sum((a-a.mean())**2)/4)\n\n1.118033988749895\n\n\n- 분모를 n-1로 나눌려면?\n\na=np.array([1,2,3,4])\na.std(ddof=1)\n\n1.2909944487358056\n\n\n\nnp.sqrt(sum((a-a.mean())**2)/3)\n\n1.2909944487358056\n\n\n\n\nargmax, argmin\n- 1차원\n\na= np.array([1,-2,3,10,4])\na\n\narray([ 1, -2,  3, 10,  4])\n\n\n\na.argmax() # 가장 큰 값이 위치한 원소의 인덱스를 리턴 \n\n3\n\n\n\na.argmin() # 가장 작은 값이 위치한 원소의 인덱스를 리턴 \n\n1\n\n\n- 2차원\n\nnp.random.seed(43052)\na=np.random.randn(4*5).reshape(4,5)\na\n\narray([[ 0.38342049,  1.0841745 ,  1.14277825,  0.30789368,  0.23778744],\n       [ 0.35595116, -1.66307542, -1.38277318, -1.92684484, -1.4862163 ],\n       [ 0.00692519, -0.03488725, -0.34357323,  0.70895648, -1.55100608],\n       [ 1.34565583, -0.05654272, -0.83017342, -1.46395159, -0.35459593]])\n\n\n\na.argmin(), a.min()\n\n(8, -1.9268448358915802)\n\n\n\na.argmax(), a.max()\n\n(15, 1.3456558341738827)\n\n\n\na.argmin(axis=0), a.argmin(axis=1)\n\n(array([2, 1, 1, 1, 2]), array([4, 3, 4, 3]))\n\n\n\na.argmax(axis=0), a.argmax(axis=1)\n\n(array([3, 0, 0, 2, 0]), array([2, 0, 3, 0]))\n\n\n\n\ncumsum, cumprod\n- 1차원\n\na=np.array([1,2,3,4])\na\n\narray([1, 2, 3, 4])\n\n\n\na.cumsum()\n\narray([ 1,  3,  6, 10])\n\n\n\na.cumprod()\n\narray([ 1,  2,  6, 24])\n\n\n- 2차원\n\na=np.array(range(3*4)).reshape(3,4)\na\n\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n\na.cumsum(axis=0), a.cumsum(axis=1)\n\n(array([[ 0,  1,  2,  3],\n        [ 4,  6,  8, 10],\n        [12, 15, 18, 21]]),\n array([[ 0,  1,  3,  6],\n        [ 4,  9, 15, 22],\n        [ 8, 17, 27, 38]]))\n\n\n\na.cumprod(axis=0), a.cumprod(axis=1)\n\n(array([[  0,   1,   2,   3],\n        [  0,   5,  12,  21],\n        [  0,  45, 120, 231]]),\n array([[   0,    0,    0,    0],\n        [   4,   20,  120,  840],\n        [   8,   72,  720, 7920]]))\n\n\n\n\ndiff\n- 1차차분\n\na=np.array([1,2,4,6,7])\na\n\narray([1, 2, 4, 6, 7])\n\n\n\nnp.diff(a)\n\narray([1, 2, 2, 1])\n\n\n- 2차차분\n\nnp.diff(np.diff(a))\n\narray([ 1,  0, -1])\n\n\n- prepend, append\n\na=np.array([1,2,4,6,7])\na\n\narray([1, 2, 4, 6, 7])\n\n\n\nnp.diff(a,prepend=100)\n#np.diff(np.array([100]+a.tolist()) )\n\narray([-99,   1,   2,   2,   1])\n\n\n\n[1,2,4,6,7] -> [100,1,2,3,4,6] -> np.diff\n\n\nnp.diff(a,append=100)\n#np.diff(np.array(a.tolist()+[100]) )\n\narray([ 1,  2,  2,  1, 93])\n\n\n(예제) a=[1,2,4,6,7]의 앞에 1을 추가하여 차분하라.\n\nnp.diff(a,prepend=a[0])\n#np.diff(a,prepend=1)\n\narray([0, 1, 2, 2, 1])\n\n\n(예제) a=[1,2,4,6,7]의 뒤에 7을 추가하여 차분하라.\n\nnp.diff(a,append=a[-1])\n#np.diff(a,append=7)\n\narray([1, 2, 2, 1, 0])\n\n\n- 2차원 array의 차분\n\na=np.arange(24).reshape(4,6)\na\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n\nnp.diff(a,axis=0) \n\narray([[6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6],\n       [6, 6, 6, 6, 6, 6]])\n\n\n\nnp.diff(a,axis=1) \n\narray([[1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1]])\n\n\n(숙제)\n\na=np.arange(24).reshape(4,6)\na\n\narray([[ 0,  1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10, 11],\n       [12, 13, 14, 15, 16, 17],\n       [18, 19, 20, 21, 22, 23]])\n\n\n에서 axis=1 옵션으로 np.diff를 적용하여 (4,5) array를 만들고 왼쪽열에 1이 포함된 column을 추가하여 최종 결과가 아래와 같이 되도록 하라.\narray([[1, 1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1, 1],\n       [1, 1, 1, 1, 1, 1]])"
  },
  {
    "objectID": "posts/python/python 1_0307.html",
    "href": "posts/python/python 1_0307.html",
    "title": "파이썬 1주차 (0307)",
    "section": "",
    "text": "- 파이썬의 기본자료형은 int, float, bool, str, list, tuple, dict, set 등이 있다.\n\n0차원 자료형: int, float, bool\n1차원 자료형: str, list, tuple, dict, set\n\n\n\n- int형\n\na=100\n\n\ntype(a)\n\nint\n\n\n- float형\n\na?\n\n\na=1.2*3\n\n\ntype(a)\n\nfloat\n\n\n- bool형\n\na=True   # 숫자1\nb=False  # 숫자0\n\n\ntype(a)\n\nbool\n\n\n\n# bool형의 연산\na+b\n\n1\n\n\n- complex형\n\na=1+2j\nb=2-2j\n\n\na\n\n(1+2j)\n\n\n\ntype(a)\n\ncomplex\n\n\n\na+b\n\n(3+0j)\n\n\n\ntype(a+b)\n\ncomplex\n\n\n- 형태변환: float -> int\n\na=3.0\ntype(a)\n\nfloat\n\n\n\na=int(a)\n\n\na?\n\n\na=3.14\nint(a)\n\n# 0.14날라가고 3만나옴. 정보의 손실이 있다.\n\n3\n\n\n- 형태변환: int $$ float\n\na=3\ntype(a)\n\nint\n\n\n\na=float(a)\ntype(a)\n\nfloat\n\n\n- 형태변환: bool $$ int/float\n(예시1)\n\na=True\ntype(a)\n\nbool\n\n\n\nint(a)\n\n1\n\n\n\nfloat(a)\n\n1.0\n\n\n(예시2)\n\na=1\nbool(a)\n\nTrue\n\n\n(예시3)\n\na=1.0\nbool(a)\n\nTrue\n\n\n\na=0.0\nbool(a)\n\nFalse\n\n\n- 이상한 형태변환도 가능하다\n\nbool(-3.14)\n\nTrue\n\n\n\nbool(3.14)\n\nTrue\n\n\n\nbool(0)\n\nFalse\n\n\n\nbool(3.24342)\n\nTrue\n\n\n\n# 위와 같은 코드를 의도적으로 사용하진 않는다. \n\n- 형태변환이 항상 가능한 것도 아님\n\nfloat(3+0j) # 사실상 3+0j= 3이므로 float으로 형변환하면 3.0이 되어야 할 것 같은데 오류가 남\n\nTypeError: can't convert complex to float\n\n\n- 암묵적형변환 (implicit)\n(예비학습) implicit의 의미 - 추운날씨 -> 보일러좀 틀자! 명시적(explicit) / 오늘 날씨가 좀 춥지 않아? (implicit) - 짜장면 먹을래? -> 싫어 (explicit) / 난 어제 짜장면 먹었는데… (implicit)\n\nint(True) #명시적\n\n1\n\n\n\nTrue * 1 # 암묵적형\n\n1\n\n\n\n1 * 1.0\n\n1.0\n\n\n\nTrue+True\n\n2\n\n\n\n\n\n- str\n\n# 선언\na='br'\n\n\na\n\n'br'\n\n\n\n# 연산\n# 더하기 연산\na='x'\nb='2'\n\n\na+b\n\n'x2'\n\n\n\n# 빼기 연산 없다. \na-b\n\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n\n\n\n# 곱하기 연산\na*2\n\n'xx'\n\n\n\n2*a\n\n'xx'\n\n\n\n# 의미상 맞지 않는 것은 수행되지 않는다.\na='x'\nb='y'\na+b\n\n'xy'\n\n\n\na*b\n\nTypeError: can't multiply sequence by non-int of type 'str'\n\n\n\n# 나눗셈연산은 없다. \na='xx'\na/2\n\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\n\n\n\n\n\n- str은 하나의 벡터 문자가 여러개 있는 형태라고 생각하기\n\na='boram'\na\n\n'boram'\n\n\n\n5개의 칸에 글씨가 하나씩 들어가 있음\n\n\na[0]  # 0이 첫번쨰 원소\n\n'b'\n\n\n\na[1] # 두번째 원소\n\n'o'\n\n\n\n# 마지막 원소를 호출하려면 -1로 호출할 수도 있다.\na[-1]\n\n'm'\n\n\n\na[4]\n\n'm'\n\n\n\na[-2]\n# 마지막에서 2번째 원소는 -2로 호출 가능\n\n'a'\n\n\n\n어려개의 원소는 :을 이용하여 호출할 수 있음\n\n\na[0:3] # a[0], a[1], a[2]까지만 뽑힌다. a[3]은 호출되지 않는다.\n\n'bor'\n\n\n\na[1:3]\n\n'or'\n\n\n\nindex=1부터 시작해서 마지막 원소까지 호출하려면?\n\n\na[5]\n\nIndexError: string index out of range\n\n\n\na[1:5]  # a[5]는 없는데,, 이렇게 쓰니까 헷갈릴 수 있다.\n\n'oram'\n\n\n\na[1:-1]   # 이것은 a[1:4] 와 같음\n\n'ora'\n\n\n\n# 해결책! 생략한다.\na[1:]\n\n'oram'\n\n\n- 생략의 응용1\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[2:]\n\n'pop'\n\n\n\na[2:5]\n\n'pop'\n\n\n- 생략의 응용2\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[0:2]\n\n'k-'\n\n\n\na[:2]   # 앞을 생략하면 첫 원소부터 나온다.\n\n'k-'\n\n\n- 생략의 응용3\n\na='k-pop'\na\n\n'k-pop'\n\n\n\na[:]\n\n'k-pop'\n\n\n\na[0:5]\n\n'k-pop'\n\n\n\n\n- 파이썬의 변수는 단순히 정보를 담는 그릇이 아니다. 유용한 기능을 제공하는 경우가 있다.\n\na='ABCD'  #a라는 변수는 'ABCD'라는 정보를 담는 그릇의 역할만 하지 않고, 특화된 어떠한 기능도 제공한다.\na\n\n'ABCD'\n\n\n\na.lower() #소문자변환\n\n'abcd'\n\n\n\n# lower()는 문자열에 특화된 기능이며 아래 내용은 안됨\na=3.14\na.lower()\n\nAttributeError: 'float' object has no attribute 'lower'\n\n\n- 자료형에 특화된 기능(=함수)을 확인하는 방법 a. + tab 으로 목록 확인 가능\n\na='boram'\n\n\na.lower?\n\n\na.upper()   # 대문자 변환\n# upper(a)\n\n'BORAM'\n\n\n\na.capitalize()\n\n'Boram'\n\n\n- 마음의눈: a.f() 형태를 읽는 팁 - a.f()는 f(a)로 생각하면 편리함 - a.f(2)는 f(a,2)로 생각하면 편리함 - 이런점에서 R %>% 연산자와 비슷하다고 생각할 수 있다. (약간 다름)\n- 사실 .은 좀 더 다양한 상황에서 쓰일 수 있다. 변수이름.함수이름() 의 형태가 아니라 - 패키지이름.함수이름() - 패키지이름.변수이름 - 패키지이름.패키지이름.함수이름()\n… 와 같이 다양한 형태가 가능하다. 근본적인 고통점은 .을 기준으로 상위개념.하위개념으로 이해하는 것이 좋다.\n\n\n\n\n- len 함수 : 원소의 갯수를 알려주는 함수\n(0차원) len함수가 동작하지 않는다.\n\na=3.14\nlen(a)\n\nTypeError: object of type 'float' has no len()\n\n\n\nb=True\nlen(b)\n\nTypeError: object of type 'bool' has no len()\n\n\n(1차원) len함수가 잘 동작함\n\na='3.14'\nlen(a)\n\n4\n\n\n\nb=[1,2,3]\nlen(b)\n\n3\n\n\n숙제\n\na='BoramKim'\na\n\n'BoramKim'\n\n\n\na[:5]\n\n'Boram'\n\n\n\na[5:]\n\n'Kim'"
  },
  {
    "objectID": "posts/python/python 3_0316.html",
    "href": "posts/python/python 3_0316.html",
    "title": "파이썬 3주차 (0316)",
    "section": "",
    "text": "- 컨테이너형타입이라는 점, 그리고 연산 및 인덱싱을 하는 방법은 리스트와 같음\n\n차이점1: [] 대신에 ()를 사용\n차이점2: 불변형이다. (원소의 값을 바꿀 수 없음)\n차이점3: 하나의 원소를 선언할 때는 (1,)와 같이 해야 한다.\n차이점4: 의미가 명확할때는 튜플의 ()를 생략가능하다.\n\n컨테이너형이라는 것이 무슨의미?\n\na=(4,6,'pencil',3.2+4.6j,[3,4])\n\n\ntype(a[3])\n\ncomplex\n\n\n\ntype(a[2])\n\nstr\n\n\n- 불변형이라는 것은 무슨 의미?\n\na[2] = 'Pencil'\n\nTypeError: 'tuple' object does not support item assignment\n\n\n참고로 a를 튜플이 아니라 리스트로 선언하면 값이 잘 바뀐다.\n- 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야함\n\n[1]+[2,3,4]\n\n[1, 2, 3, 4]\n\n\n\n(1)+(2,3,4)   # int형+tuple형 이므로 계산 불가 \n\nTypeError: unsupported operand type(s) for +: 'int' and 'tuple'\n\n\n\ntype(1)\n\nint\n\n\n\n(1,)+(2,3,4)\n\n(1, 2, 3, 4)\n\n\n- 마지막차이점! 의미가 명확할때 튜플의 괄호는 생략가능하다. (중요)\n\na=(1,2)\na\n\n(1, 2)\n\n\n의미가 명확할때 생략해야함\n\n1,2 + 3,4,5\n\n(1, 5, 4, 5)\n\n\n\n(1,2)+(3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n\n\n- 소괄호를 이용\n\na=(1,2,3)\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 생략가능하다는 점이 포인트\n\na=1,2,3\na\n\n(1, 2, 3)\n\n\n\ntype(a)\n\ntuple\n\n\n- 원소가 하나인 튜플을 만들고 싶다면?\n\na=(1,)\na\n\n(1,)\n\n\n\n\n\n- 리스트와 동일\n\n(1,2)+(3,4,5)\n\n(1, 2, 3, 4, 5)\n\n\n\n(1,2)*2\n\n(1, 2, 1, 2)\n\n\n\n\n\n- 리스트와 동일\n\na=(1,2,3,-4,-5)\na\n\n(1, 2, 3, -4, -5)\n\n\n\na[-1]\n\n-5\n\n\n\na[-3:]\n\n(3, -4, -5)\n\n\n\n\n\n\n\n\n책의설명: 실수로 값이 변경되는 것을 방지할 수 있다.\nshaaly copy / deep copy 를 막을 수 있는 무기\n\n\n\n\n- 예제: 여러변수를 동시에 출력하고 싶을 경우 (다중출력?)\n변수를 아래와 같이 선언하였다고 하자.\n\na=1\nb=2\nc=3\n\n선언된 값을 확인하려면?\n\na\n\n1\n\n\n\nb\n\n2\n\n\n\nc\n\n3\n\n\n튜플을 이용하면?\n\na,b,c #괄호하나 생략하는 것이 편함\n\n(1, 2, 3)\n\n\n- 예제: 다중할당1 (여러개의 변수를 동시에 선언하고 싶을 경우)\n\nname, age, sex, height, weight = 'Tom', 20, 'M', 180, 70\n\n\nname, age, sex, height, weight\n\n('Tom', 20, 'M', 180, 70)\n\n\n\nheight\n\n180\n\n\n- 예제: 다중할당2, 위도와 경도\n\ncoor = (37,127) #서울\ncoor\n\n(37, 127)\n\n\n\nlat, long = coor   # (왼쪽) 가로가 생략된 튜플 \n\n\nlat\n\n37\n\n\n\nlong\n\n127\n\n\n- 잠깐만: 다중할당은 꼭 튜플에서만 가능한가?\n\n[x,y,z] = [1,2,3]\nx,y,z # 다중출력\n\n(1, 2, 3)\n\n\n\n[x,y] = 'hi'\nx,y\n\n('h', 'i')\n\n\n튜플과 같이 사용하면 가독성이 극대화 (그래서 다중할당은 거의 튜플과 세트로 사용함)\n\nx,y,z=1,2,3\nx,y,z\n\n(1, 2, 3)\n\n\n- 예제: 임시변수 사용없이 두 변수의 값을 교환\n\na=10\nb=20\n\n\na,b= b,a\n\n\na\n\n20\n\n\n\nb\n\n10\n\n\n- 예제: for문과 튜플\n\nlst = [['boram', 202212345, 'F'],\n      ['iu',202212365,'F'],\n      ['hodong',202215323,'M']]\nlst\n\n[['boram', 202212345, 'F'], ['iu', 202212365, 'F'], ['hodong', 202215323, 'M']]\n\n\n\nfor i in lst:\n    print(i)\n\n['boram', 202212345, 'F']\n['iu', 202212365, 'F']\n['hodong', 202215323, 'M']\n\n\n\nfor name, studentid, sex in lst:\n    print(name)\n\nboram\niu\nhodong\n\n\n\nfor name, studentid, sex in lst:\n    print(name, sex)\n\nboram F\niu F\nhodong M\n\n\n- 예제: for문과 튜플, dummy variable _\n\nfor name, studentid, sex in lst:\n    print(name)\n\nboram\niu\nhodong\n\n\n\nfor name, _, _ in lst:\n    print(name)   #name만 관심있으므로 그 외는 언더바를 통해 작성하는 편리함\n\nboram\niu\nhodong\n\n\n\nfor name, _ in lst:\n    print(name)\n\nValueError: too many values to unpack (expected 2)\n\n\n\nfor name, *args in lst:    #  *args 를 통해 위 오류 해결\n    print(name)\n\nboram\niu\nhodong\n\n\n- 예제: 튜플과 언패킹연산자 *\n\nhead, body, *tail = range(1,11)\nhead, body, tail\n\n(1, 2, [3, 4, 5, 6, 7, 8, 9, 10])\n\n\n\nhead1, head2, *body, tail1, tail2, tail3 = range(1,11)\nhead1, head2, body, tail1, tail2, tail3\n\n(1, 2, [3, 4, 5, 6, 7], 8, 9, 10)\n\n\n\nhead1, *body, tail1, *tail2, *tail3 = range(1,11) #명확하지 않아서 오류남\n\nSyntaxError: multiple starred expressions in assignment (2478039376.py, line 1)\n\n\n\n*head, body, tail1, tail2, tail3 = range(1,11)\nhead, body, tail1\n\n([1, 2, 3, 4, 5, 6], 7, 8)\n\n\n(관찰)\nhead1, head2, body, tail1, tail2, tail3 = (1, 2, [3, 4, 5, 6, 7], 8, 9, 10)\nhead1, head3, *body, tail1, tail2, tail3 = (1,2, 3,4,5,6,7, 8, 9, 10) \n* 를 붙이면 1차원 자료구조가 풀린다!\n\n*[1,2,3]\n\nSyntaxError: can't use starred expression here (386627056.py, line 1)\n\n\n\nprint([1,2,3])\n\n[1, 2, 3]\n\n\n\nprint(*[1,2,3])   # 풀린다!!!\n\n1 2 3\n\n\n- 예제: 함수의 입력으로 *args 를 넣을때\n[예비학습] 함수 벼락치기\n\ndef myadd(a,b):\n    return a+b\n\n\nmyadd(3,4)\n\n7\n\n\n\nmyadd(3,-3)\n\n0\n\n\n예제: 두 점 사이의 거리를 구하는 함수를 만들어 보자.\n점 \\(p=(p_x,p_y)\\) 와 \\(q=(q_x,q_y)\\)의 거리는 \\(\\sqrt{(p_x-q_x)^2, (p_y-q_y)^2}\\)이다. 이것을 계산하는 프로그램을 만들자\n\nimport numpy as np\ndef dist(px,py,qx,qy):\n    return np.sqrt((px-qx)**2 + (py-qy)**2)\n\n\n\ndist(0,3,4,0) # 헷갈려\n\n5.0\n\n\n\np=(0,3)\nq=(4,0)\ndist(p,q)\n\nTypeError: dist() missing 2 required positional arguments: 'qx' and 'qy'\n\n\n(방법1)\n\npx, py = p #또는(0,3)\nqx, qy = (4,0)\ndist(px,py,qx,qy)\n\n5.0\n\n\n(방법2)\n\ndef dist2(p, q):\n    px, py = p\n    qx, qy = q\n    return np.sqrt((px-qx)**2 + (py-qy)**2)\n\n\n#def dist2(p, q):\n#    px=p[0]\n#    py=p[1]\n#    qx=q[0]\n#    qy=q[1]\n#    return np.sqrt((px-qx)**2 + (py-qy)**2)\n\n\np=(0,3)\nq=(4,0)\ndist2(p,q)\n\n5.0\n\n\n(방법3)\n\ndist(*p, *q)    # 입력을 *(px,py), *(qx, qy) 형태로 넣기도 하고\n\n5.0\n\n\n\ndist(px, py, qx, qy)  # 입력을 px,py,qx,qy 형태로 넣기도 하고\n\n5.0\n\n\n(숙제) 원소로 자기학번을 포함하는 튜플을 만들기 (길이가 1인 튜플)\n\ntype((202250926,))\n\ntuple\n\n\n\nlen((202250926,))\n\n1\n\n\n\nㅁ"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "coco",
    "section": "",
    "text": "파이썬 7주차 (0418)\n\n\n\n\n\n\n\nnumpy (메소드 도움말확인, hstack, vstack, append, ravel, flatten, 기타통계함수들, dtype, 브로드캐스팅), matploblib (plt.pyplot, plt.hist)\n\n\n\n\n\n\n\n\n\n\n\nApr 18, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 7주차 (0413)\n\n\n\n\n\n\n\nnumpy (rand, randn, randint, choice, 통계분포, np.where/np.argwhere, 인덱싱고급, np.ix_)\n\n\n\n\n\n\n\n\n\n\n\nApr 13, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 6주차 (0411)\n\n\n\n\n\n\n\nnumpy (@, concat, stack, sum, mean, std, max, min, prod, argmax, argmin, cumsum, cumprod, diff)\n\n\n\n\n\n\n\n\n\n\n\nApr 11, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 5주차 (0406)\n\n\n\n\n\n\n\nnumpy (선언, 브로드캐스팅, 수학연산, 인덱싱, reshape, 랜덤으로 생성, 행렬관련기능)\n\n\n\n\n\n\n\n\n\n\n\nApr 6, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 5주차 (0404)\n\n\n\n\n\n\n\n소스코드 관리(모듈, 패키지, 라이브러리)\n\n\n\n\n\n\n\n\n\n\n\nApr 4, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 4주차 (0328)\n\n\n\n\n\n\n\n개발환경 변천사 1~5세대 프로그래머\n\n\n\n\n\n\n\n\n\n\n\nMar 28, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 4주차 (0323)\n\n\n\n\n\n\n\n딕셔너리, 집합\n\n\n\n\n\n\n\n\n\n\n\nMar 23, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 3주차 (0321)\n\n\n\n\n\n\n\n스트라이딩, 컴프리헨션고급, len함수, 딕셔너리\n\n\n\n\n\n\n\n\n\n\n\nMar 21, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 3주차 (0316)\n\n\n\n\n\n\n\n튜플\n\n\n\n\n\n\n\n\n\n\n\nMar 16, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 2주차 (0314)\n\n\n\n\n\n\n\n리스트(선언, 연산, 인덱싱, 콘테이너형 객체, 가변객체, 매소드, 중첩리스트, 리스트컴프리헨션)\n\n\n\n\n\n\n\n\n\n\n\nMar 14, 2022\n\n\n김보람\n\n\n\n\n\n\n\n\n파이썬 1주차 (0307)\n\n\n\n\n\n\n\nint, float, bool, str 자료형\n\n\n\n\n\n\n\n\n\n\n\nMar 7, 2022\n\n\n김보람\n\n\n\n\n\n\nNo matching items"
  }
]